Index: src/code.py
===================================================================
diff --git a/src/code.py b/src/code_test.py
rename from src/code.py
rename to src/code_test.py
--- a/src/code.py	
+++ b/src/code_test.py	
@@ -82,7 +82,7 @@
 def session_manager():
     """
     Sort out our session manager. We use a global in the utils module
-    to hold the session to make sure if the app/code.py is reloaded it
+    to hold the session to make sure if the app/code_test.py is reloaded it
     always gets the same session manager.
     """
     class MemCacheStore(web.session.Store):
Index: src/asm3/i18n.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\nimport datetime\nimport json\nimport time\n\n# flake8: noqa - we have a lot of locales and this is convenient\nfrom asm3.locales import *\n\nVERSION = \"46u [Fri 22 Jul 2022 15:44:58 IDT]\"\nBUILD = \"07221544\"\n\nDMY = ( \"%d/%m/%Y\", \"%d/%m/%y\" )\nHDMY = ( \"%d-%m-%Y\", \"%d-%m-%y\" )\nDDMY = ( \"%d.%m.%Y\", \"%d.%m.%y\" )\nMDY = ( \"%m/%d/%Y\", \"%m/%d/%y\" )\nYMD = ( \"%Y/%m/%d\", \"%y/%m/%d\" )\nDYMD = ( \"%Y.%m.%d\", \"%y.%m.%d\" )\nHYMD = ( \"%Y-%m-%d\", \"%y-%m-%d\" )\nDOLLAR = \"$\"\nEURO = \"&#x20ac;\"\nPOUND = \"&pound;\"\nYEN = \"&yen;\"\nCURRENCY_PREFIX = \"p\"\nCURRENCY_SUFFIX = \"s\"\nDST_US = \"6-203-111\"\nDST_UK = \"6-L03-L10\"\nDST_AU = \"6-110-104\"\n\ndef PLURAL_ENGLISH(n):\n    \"\"\" gettext plural function for English/Latin languages \"\"\"\n    if n == 1: return 0\n    return 1\n\ndef PLURAL_HUNGARIAN(n):\n    \"\"\" gettext style plural function for Hungarian \n        Hungarian always uses the singular unless the element appears\n        by itself (which it never does for the purposes of ngettext)\n        so always return the singular\n    \"\"\"\n    return 0\n\ndef PLURAL_POLISH(n):\n    \"\"\" gettext style plural function for Polish \"\"\"\n    if n == 1: return 0\n    if n % 10 >= 2 and n % 10 <= 4 and (n % 100 < 10 or n % 100 >= 20): return 1\n    return 2\n\ndef PLURAL_SLAVIC(n):\n    \"\"\" gettext style plural function for Slavic languages,\n        Russian, Ukrainian, Belarusian, Serbian, Croatian\n    \"\"\"\n    if n % 10 == 1 and n % 100 != 11: return 0\n    if n % 10 >= 2 and n % 10 <= 4 and (n % 100 < 10 or n % 100 >= 20): return 1\n    return 2\n\n# Maps of locale to currency/date format - this is a map of lists instead of maps\n# to try and keep things readable and on one line\nLM_LANGUAGE = 0\nLM_COUNTRY = 1\nLM_DATEFORMAT = 2\nLM_CURRENCY_SYMBOL = 3\nLM_PLURAL_FUNCTION = 4\nLM_CURRENCY_POSITION = 5\nLM_CURRENCY_DECIMAL_PLACES = 6\nLM_CURRENCY_DECIMAL_MARK = 7\nLM_CURRENCY_DIGIT_GROUPING = 8\nLM_DST = 9\nlocale_maps = {\n    \"en\":       ( \"English\", \"United States\", MDY, DOLLAR, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", DST_US ),\n    \"en_GB\":    ( \"English\", \"Great Britain\", DMY, POUND, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", DST_UK ),\n    \"en_AU\":    ( \"English\", \"Australia\", DMY, DOLLAR, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", DST_AU ),\n    \"en_AE\":    ( \"English\", \"United Arab Emirates\", DMY, \"&#x62f;&#x2e;&#x625;\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"\"),\n    \"en_AW\":    ( \"English\", \"Aruba\", DMY, \"Awg.\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"\" ),\n    \"en_BE\":    ( \"English\", \"Belgium\", DMY, EURO, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \",\", \" \", DST_UK ),\n    \"en_BM\":    ( \"English\", \"Bermuda\", DMY, DOLLAR, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"6-203-111\" ),\n    \"en_BG\":    ( \"English\", \"Bulgaria\", HYMD, \"&#x043b;&#x0432;\", PLURAL_ENGLISH, CURRENCY_SUFFIX, 2, \",\", \" \", DST_UK),\n    \"en_BH\":    ( \"English\", \"Bahrain\", MDY, \"BD\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"\", \"\" ),\n    \"en_BQ\":    ( \"English\", \"Bonaire\", DMY, DOLLAR, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"\" ),\n    \"en_CA\":    ( \"English\", \"Canada\", MDY, DOLLAR, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", DST_US ),\n    \"en_CH\":    ( \"English\", \"Switzerland\", DDMY, \"CHF\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", DST_UK ),\n    \"en_CN\":    ( \"English\", \"China\", HYMD, YEN, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"\" ),\n    \"en_CR\":    ( \"English\", \"Costa Rica\", DMY, \"&#8353;\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"\" ),\n    \"en_CY\":    ( \"English\", \"Cyprus\", DMY, EURO, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", DST_UK ),\n    \"en_ES\":    ( \"English\", \"Spain\", DMY, EURO, PLURAL_ENGLISH, CURRENCY_SUFFIX, 2, \",\", \" \", DST_UK ),\n    \"en_HK\":    ( \"English\", \"Hong Kong\", HDMY, DOLLAR, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"\" ),\n    \"en_KH\":    ( \"English\", \"Cambodia\", DMY, DOLLAR, PLURAL_ENGLISH, CURRENCY_SUFFIX, 2, \".\", \",\", \"\" ),\n    \"en_KW\":    ( \"English\", \"Kuwait\", DMY, \"KD\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"\" ),\n    \"en_KY\":    ( \"English\", \"Cayman Islands\", DMY, DOLLAR, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"\" ),\n    \"en_IE\":    ( \"English\", \"Ireland\", DMY, EURO, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", DST_UK ),\n    \"en_IN\":    ( \"English\", \"India\", DMY, \"&#8377;\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"\"),\n    \"en_IL\":    ( \"English\", \"Israel\", DMY, \"&#x20aa;\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", DST_UK ),\n    \"en_JP\":    ( \"English\", \"Japan\", YMD, \"&yen;\", PLURAL_ENGLISH, CURRENCY_SUFFIX, 0, \".\", \",\", \"\" ),\n    \"en_KE\":    ( \"English\", \"Kenya\", DMY, \"Ksh\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"\" ),\n    \"en_LB\":    ( \"English\", \"Lebanon\", MDY, \"L&pound;\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", DST_UK ),\n    \"en_LU\":    ( \"English\", \"Luxembourg\", DDMY, EURO, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", DST_UK ),\n    \"en_MU\":    ( \"English\", \"Mauritius\", DMY, \"&#8360;\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"\"),\n    \"en_MY\":    ( \"English\", \"Malaysia\", DMY, \"RM\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"\" ),\n    \"en_MX\":    ( \"English\", \"Mexico\", DMY, DOLLAR, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"6-104-L10\" ),\n    \"en_MZ\":    ( \"English\", \"Mozambique\", DMY, \"MT\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"\" ),\n    \"en_NA\":    ( \"English\", \"Namibia\", YMD, DOLLAR, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \",\", \" \", \"\"),\n    \"en_PH\":    ( \"English\", \"Philippines\", MDY, \"&#x20b1;\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"\"),\n    \"en_QA\":    ( \"English\", \"Qatar\", DMY, \"QR\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"\"),\n    \"en_NZ\":    ( \"English\", \"New Zealand\", DMY, DOLLAR, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"6-L09-104\" ),\n    \"en_TH\":    ( \"English\", \"Thailand\", DMY, \"&#x0e3f;\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"\" ),\n    \"en_TW\":    ( \"English\", \"Taiwan\", YMD, DOLLAR, PLURAL_ENGLISH, CURRENCY_PREFIX, 0, \".\", \",\", \"\"),\n    \"en_TW2\":   ( \"English\", \"Taiwan $0.00\", YMD, DOLLAR, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"\" ),\n    \"en_TZ\":    ( \"English\", \"Tanzania\", DMY, \"Tsh\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"\" ),\n    \"en_VN\":    ( \"English\", \"Vietnam\", DMY, \"&#8363;\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"\" ),\n    \"en_ZA\":    ( \"English\", \"South Africa\", YMD, \"R\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \",\", \" \", \"\"),\n    \"bg\":       ( \"Bulgarian\", \"Bulgaria\", DDMY, \"&#x043b;&#x0432;\", PLURAL_ENGLISH, CURRENCY_SUFFIX, 2, \",\", \" \", DST_UK),\n    \"bs\":       ( \"Bosnian\", \"Bosnia\", HYMD, \"KM\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", DST_UK),\n    \"cs\":       ( \"Czech\", \"Czech Republic\", DYMD, \"&#x004b;&#x010d;\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \",\", \" \", DST_UK ),\n    \"de\":       ( \"German\", \"Germany\", DDMY, EURO, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \",\", \" \", DST_UK ),\n    \"de_AT\":    ( \"German\", \"Austria\", DDMY, EURO, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", DST_UK ),\n    \"de_CH\":    ( \"German\", \"Switzerland\", DDMY, \"CHF\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", DST_UK ),\n    \"de_LU\":    ( \"German\", \"Luxembourg\", DDMY, EURO, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", DST_UK ),\n    \"el\":       ( \"Greek\", \"Greece\", DMY, EURO, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \",\", \" \", DST_UK ),\n    \"es\":       ( \"Spanish\", \"Spain\", DMY, EURO, PLURAL_ENGLISH, CURRENCY_SUFFIX, 2, \",\", \" \", DST_UK ),\n    \"es_CO\":    ( \"Spanish\", \"Columbia\", DMY, DOLLAR, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \",\", \" \", \"\" ),\n    \"es_CR\":    ( \"Spanish\", \"Costa Rica\", DMY, \"&#8353;\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \",\", \" \", \"\" ),\n    \"es_EC\":    ( \"Spanish\", \"Ecuador\", DMY, DOLLAR, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \",\", \" \", \"\" ),\n    \"es_MX\":    ( \"Spanish\", \"Mexico\", DMY, DOLLAR, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"6-104-L10\" ),\n    \"et\":       ( \"Estonian\", \"Estonia\", DMY, \"kr\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \",\", \" \", DST_UK ),\n    \"fi\":       ( \"Finnish\", \"Finland\", DDMY, EURO, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \",\", \" \", DST_UK),\n    \"fr\":       ( \"French\", \"France\", DMY, EURO, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \",\", \" \", DST_UK ),\n    \"fr_BE\":    ( \"French\", \"Belgium\", DMY, EURO, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \",\", \" \", DST_UK ),\n    \"fr_LU\":    ( \"French\", \"Luxembourg\", DDMY, EURO, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", DST_UK ),\n    \"fr_CA\":    ( \"French\", \"Canada\", DMY, DOLLAR, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \",\", \" \", DST_US ),\n    \"fr_CH\":    ( \"French\", \"Switzerland\", DDMY, \"CHF\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", DST_UK ),\n    \"he\":       ( \"Hebrew\", \"Israel\", DMY, \"&#x20aa;\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", DST_UK ),\n    \"hu\":       ( \"Hungarian\", \"Hungary\", DYMD, \"Ft\",  PLURAL_HUNGARIAN, CURRENCY_PREFIX, 2, \",\", \" \", DST_UK), \n    \"it\":       ( \"Italian\", \"Italy\", DMY, EURO, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \",\", \" \", DST_UK ),\n    \"it_CH\":    ( \"Italian\", \"Switzerland\", DDMY, \"CHF\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", DST_UK ),\n    \"lt\":       ( \"Lithuanian\", \"Lithuania\", DYMD, EURO, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \",\", \" \", DST_UK ),\n    \"nb\":       ( \"Norwegian Bokmal\", \"Norway\", DDMY, \"kr\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \",\", \" \", DST_UK ),\n    \"nl\":       ( \"Dutch\", \"Holland\", HDMY, EURO, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \",\", \" \", DST_UK ),\n    \"nl_AW\":    ( \"Dutch\", \"Aruba\", DMY, \"Awg.\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"\" ),\n    \"nl_BE\":    ( \"Dutch\", \"Belgium\", DMY, EURO, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \",\", \" \", DST_UK ),\n    \"nl_BQ\":    ( \"Dutch\", \"Bonaire\", DMY, DOLLAR, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"\" ),\n    \"pl\":       ( \"Polish\", \"Poland\", DDMY, \"&#x007a;&#x0142;\", PLURAL_POLISH, CURRENCY_PREFIX, 2, \",\", \" \", DST_UK ),\n    \"pt\":       ( \"Portuguese\", \"Portugal\", HDMY, EURO, PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \",\", \" \", DST_UK ),\n    \"pt_MZ\":    ( \"Portuguese\", \"Mozambique\", DMY, \"MT\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"\" ),\n    \"ru\":       ( \"Russian\", \"Russia\", DDMY, \"&#1056;&#1059;&#1041;.\", PLURAL_SLAVIC, CURRENCY_PREFIX, 2, \",\", \" \", \"\" ),\n    \"sk\":       ( \"Slovakian\", \"Slovakia\", DDMY, EURO, PLURAL_SLAVIC, CURRENCY_PREFIX, 2, \",\", \" \", DST_UK ),\n    \"sl\":       ( \"Slovenian\", \"Slovenia\", DDMY, EURO, PLURAL_SLAVIC, CURRENCY_PREFIX, 2, \",\", \" \", DST_UK ),\n    \"sv\":       ( \"Swedish\", \"Sweden\", HYMD, \"kr\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \",\", \" \", DST_UK ),\n    \"th\":       ( \"Thai\", \"Thailand\", DMY, \"&#x0e3f;\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \".\", \",\", \"\" ),\n    \"tr\":       ( \"Turkish\", \"Turkey\", DDMY, \"TL\", PLURAL_ENGLISH, CURRENCY_PREFIX, 2, \",\", \" \", \"\" )\n}\n\ndef _(english, locale = \"en\"):\n    return translate(english, locale)\n\ndef real_locale(locale = \"en\"):\n    # When translating text strings, treat some locales as pointers \n    # to other locales without the need for a full translation:\n    # Our core English locales (with actual differences) are:\n    #   en    (US)\n    #   en_AU (Australia)\n    #   en_CA (Canada)\n    #   en_GB (UK)\n    if locale in (\"en_AE\", \"en_BE\", \"en_BG\", \"en_BM\", \"en_BQ\", \"en_CH\", \"en_CN\", \"en_CY\", \"en_ES\", \n        \"en_HK\", \"en_IE\", \"en_IN\", \"en_JP\", \"en_KE\", \"en_KH\", \"en_LB\", \"en_LU\", \"en_MU\", \"en_MY\", \"en_MZ\", \n        \"en_NA\", \"en_PH\", \"en_QA\", \"en_TH\", \"en_TW\", \"en_TW2\", \"en_TZ\", \"en_VN\", \"en_ZA\"):\n        locale = \"en_GB\"\n    if locale in (\"en_AW\", \"en_BH\", \"en_CO\", \"en_CR\", \"en_KW\", \"en_KY\", \"en_IL\", \"en_LB\", \n        \"en_MX\"):\n        locale = \"en\"\n    if locale in (\"en_NZ\",):\n        locale = \"en_AU\"\n    # Dutch locales\n    if locale in (\"nl_AW\", \"nl_BE\", \"nl_BQ\"):\n        locale = \"nl\"\n    # French locales\n    if locale in (\"fr_BE\", \"fr_CH\", \"fr_LU\"):\n        locale = \"fr\"\n    # German locales\n    if locale in (\"de_AT\", \"de_CH\", \"de_LU\"):\n        locale = \"de\"\n    # Italian locales\n    if locale in (\"it_CH\",):\n        locale = \"it\"\n    # Portguese locales\n    if locale in (\"pt_MZ\",):\n        locale = \"pt\"\n    # Spanish locales\n    if locale in (\"es_CO\", \"es_CR\", \"es_EC\", \"es_MX\"):\n        locale = \"es\"\n    return locale\n\ndef translate(english, locale = \"en\"):\n    \"\"\"\n    Returns a translation string for an English phrase in\n    the locale given.\n    \"\"\"\n    locale = real_locale(locale)\n\n    # If we're dealing with English, then just\n    # return the English phrase. I hate that I'm doing\n    # this, but I'm going with the accepted standard of\n    # US English being default even though we invented\n    # the bloody language.\n    if locale == \"en\":\n        return english\n\n    # Otherwise, look up the phrase in the correct\n    # module for our locale.\n    try:\n        lang = globals()[\"locale_\" + locale]\n    except:\n        # The module doesn't exist for the locale, fall\n        # back to plain English translation\n        return english\n\n    # If the string isn't in our locale dictionary, fall back to English\n    if english not in lang.val: return english\n\n    # If the value hasn't been translated, fall back to English\n    s = lang.val[english]\n    if s is None or s == \"\" or s.startswith(\"??\") or s.startswith(\"(??\"):\n        return english\n    else:\n        return lang.val[english]\n\ndef ntranslate(number, translations, locale = \"en\"):\n    \"\"\" Translates a phrase that deals with a number of something\n        so the correct plural can be used. \n        number: The number of items\n        translations: A list of already translated strings for each plural form\n        locale: The locale the strings are in (which plural function to use)\n    \"\"\"\n    try:\n        pluralfun = get_plural_function(locale)\n        text = translations[pluralfun(number)]\n        text = text.replace(\"{plural0}\", str(number))\n        text = text.replace(\"{plural1}\", str(number))\n        text = text.replace(\"{plural2}\", str(number))\n        text = text.replace(\"{plural3}\", str(number))\n        text = text.replace(\"{plural4}\", str(number))\n        return text\n    except Exception as e:\n        return e\n\ndef get_version():\n    \"\"\"\n    Returns the version of ASM\n    \"\"\"\n    return VERSION\n\ndef get_version_number():\n    \"\"\"\n    Returns the version number of ASM\n    \"\"\"\n    return VERSION[0:VERSION.find(\" \")]\n\ndef get_locale_map(locale, index):\n    if locale in locale_maps:\n        return locale_maps[locale][index]\n    else:\n        return locale_maps[\"en\"][index]\n\ndef get_locales():\n    locales = []\n    # Build a list of locale, display name\n    for k, v in locale_maps.items():\n        if k.find(\"_\") != -1 and k != \"en\":\n            locales.append( (k, \"%s (%s)\" % (v[LM_LANGUAGE], v[LM_COUNTRY])) )\n        else:\n            locales.append( (k, \"%s\" % v[LM_LANGUAGE]) )\n    # Sort on display name alphabetically\n    locales = sorted(locales, key=lambda x: x[1])\n    return locales\n\ndef get_country(locale):\n    return get_locale_map(locale, LM_COUNTRY)\n\ndef get_language(locale):\n    return get_locale_map(locale, LM_LANGUAGE)\n\ndef get_display_date_format(locale, digitsinyear = 4):\n    \"\"\"\n    Returns the display date format for a locale\n    \"\"\"\n    if digitsinyear == 4:\n        return get_locale_map(locale, LM_DATEFORMAT)[0]\n    else:\n        return get_locale_map(locale, LM_DATEFORMAT)[1]\n\ndef get_currency_symbol(locale):\n    \"\"\"\n    Returns the currency symbol for a locale\n    \"\"\"\n    return get_locale_map(locale, LM_CURRENCY_SYMBOL)\n\ndef get_currency_prefix(locale):\n    \"\"\"\n    Returns \"p\" if the currency symbol goes at the beginning, or \"s\" for the end\n    when displaying.\n    \"\"\"\n    return get_locale_map(locale, LM_CURRENCY_POSITION)\n\ndef get_currency_dp(locale):\n    \"\"\"\n    Returns the number of decimal places for a locale when\n    displaying currency\n    \"\"\"\n    return get_locale_map(locale, LM_CURRENCY_DECIMAL_PLACES)\n\ndef get_currency_radix(locale):\n    \"\"\"\n    Returns the decimal mark symbol\n    \"\"\"\n    return get_locale_map(locale, LM_CURRENCY_DECIMAL_MARK)\n\ndef get_currency_digit_grouping(locale):\n    \"\"\"\n    Returns the character used to separate thousands\n    \"\"\"\n    return get_locale_map(locale, LM_CURRENCY_DIGIT_GROUPING)\n\ndef get_dst(locale):\n    \"\"\"\n    Returns the daylight savings time info for locale\n    \"\"\"\n    return get_locale_map(locale, LM_DST)\n\ndef get_plural_function(locale):\n    \"\"\"\n    Returns the function for calculating plurals for this locale\n    \"\"\"\n    return get_locale_map(locale, LM_PLURAL_FUNCTION)\n\ndef cint(s):\n    try:\n        return int(s)\n    except:\n        return 0\n\ndef format_currency(locale, value, includeSymbol = True):\n    \"\"\"\n    Formats a currency value to the correct number of \n    decimal places and returns it as a string\n    \"\"\"\n    if value is None: value = 0\n    i = 0\n    f = 0.0\n    try:\n        i = int(value)\n        f = float(i)\n    except:\n        pass\n    f = f / 100\n    dp = str(get_currency_dp(locale))\n    symbol = get_currency_symbol(locale)\n    # Start with a basic currency format with comma groupings every 3 digits\n    # and the right number of decimal places for the locale\n    fstr = \"{:,.\" + dp + \"f}\"\n    # Add the currency symbol to the format in the correct spot\n    if includeSymbol:\n        if get_currency_prefix(locale) == CURRENCY_PREFIX:\n            fstr = symbol + fstr\n        else:\n            fstr += symbol\n    # If it's negative, wrap brackets around the format\n    if f < 0: \n        f = abs(f)\n        fstr = \"(\" + fstr + \")\"\n    # Do the format to get our value\n    s = fstr.format(f)\n    # Substitute the grouping and radix symbols based on locale\n    s = s.replace(\",\", \"GRP\").replace(\".\", \"RDX\")\n    s = s.replace(\"GRP\", get_currency_digit_grouping(locale))\n    s = s.replace(\"RDX\", get_currency_radix(locale))\n    return s\n\ndef format_currency_no_symbol(locale, value):\n    \"\"\" \n    Formats a currency value, but leaves off the currency symbol\n    \"\"\"\n    return format_currency(locale, value, includeSymbol = False)\n\ndef format_time(d, timeformat=\"%H:%M:%S\"):\n    if d is None: return \"\"\n    return time.strftime(timeformat, d.timetuple())\n\ndef format_time_now(offset = 0.0):\n    return format_time(now(offset))\n\ndef http_date(dt):\n    \"\"\"\n    Formats a UTC python date/time in HTTP (RFC1123) format\n    \"\"\"\n    weekday = [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"][dt.weekday()]\n    month = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\",\n             \"Oct\", \"Nov\", \"Dec\"][dt.month - 1]\n    return \"%s, %02d %s %04d %02d:%02d:%02d GMT\" % (weekday, dt.day, month,\n        dt.year, dt.hour, dt.minute, dt.second)\n\ndef python2display(locale, d):\n    \"\"\"\n    Formats a python date as a display string. \n    'd' is a Python date, return value is a display string.\n    \"\"\"\n    if d is None: return \"\"\n    try:\n        return time.strftime(get_display_date_format(locale), d.timetuple())\n    except:\n        return \"\"\n\ndef python2displaytime(locale, d):\n    \"\"\"\n    Formats a python date as a display string with time info (if not midnight).\n    'd' is a Python date, return value is a display string with time info.\n    \"\"\"\n    if d is None: return \"\"\n    try:\n        ds = time.strftime(get_display_date_format(locale), d.timetuple())\n        ts = \"\"\n        if str(d).find(\"00:00:00\") == -1: \n            return \"%s %s\" % (ds, format_time(d))\n        return ds\n    except:\n        return \"\"\n\ndef python2unix(d):\n    \"\"\"\n    Converts a python date to unix.\n    \"\"\"\n    try:\n        return time.mktime(d.timetuple())\n    except:\n        return 0\n\ndef format_date(d, dateformat=\"%Y-%m-%d\"):\n    \"\"\"\n    Formats a python date to the format given (strftime rules)\n    \"\"\"\n    if d is None: return \"\"\n    try:\n        return time.strftime(dateformat, d.timetuple())\n    except:\n        return \"\"\n\ndef display2python(locale, d):\n    \"\"\"\n    Parses a display string back to python format. Can cope with\n    2 or 4 digit years.\n    'd' is a string. return value is the date or None if it\n    could not be parsed.\n    If an ISO date YYYY-MM-DD is passed by mistake, it will cope with that too (handy for posts from html5 date input)\n    \"\"\"\n    if d is None: return None\n    if len(d) == 10 and d[4] == \"-\" and d[7] == \"-\": return datetime.datetime.strptime(d, \"%Y-%m-%d\")\n    try:\n        return datetime.datetime.strptime(d, get_display_date_format(locale, 2))\n    except:\n        try:\n            return datetime.datetime.strptime(d, get_display_date_format(locale, 4))\n        except:\n            return None\n\ndef parse_date(dateformat, d):\n    \"\"\"\n    Parses a python date from the dateformat given\n    \"\"\"\n    try:\n        return datetime.datetime.strptime(d, dateformat)\n    except:\n        return None\n\ndef parse_time(d, t):\n    \"\"\"\n    Parses the time t and combines it with python date d\n    \"\"\"\n    if d is None: return None\n    tbits = t.split(\":\")\n    hour = 0\n    minute = 0\n    second = 0\n    if len(tbits) > 0: hour = cint(tbits[0])\n    if len(tbits) > 1: minute = cint(tbits[1])\n    if len(tbits) > 2: second = cint(tbits[2])\n    t = datetime.time(hour, minute, second)\n    d = d.combine(d, t)\n    return d\n\ndef yes_no(l, condition):\n    if condition:\n        return _(\"Yes\", l)\n    else:\n        return _(\"No\", l)\n\ndef yes_no_unknown(l, v):\n    if v == 0: return _(\"Yes\", l)\n    elif v == 1: return _(\"No\", l)\n    else: return _(\"Unknown\", l)\n\ndef yes_no_unknown_blank(l, v):\n    if v == 0: return _(\"Yes\", l)\n    elif v == 1: return _(\"No\", l)\n    else: return \"\"\n\ndef add_months(date, months = 1):\n    \"\"\"\n    Adds calendar months to a date, returning a new datetime\n    \"\"\"\n    newmonth = ((( date.month - 1) + months ) % 12 ) + 1\n    newyear  = date.year + ((( date.month - 1) + months ) // 12 )\n    try:\n        return datetime.datetime( newyear, newmonth, date.day )\n    except:\n        return datetime.datetime( newyear, newmonth, 28 )\n\ndef add_years(date, years = 1.0):\n    \"\"\"\n    Adds years to a date, returning a new datetime\n    \"\"\"\n    if date is None: return None\n    if date.day == 29 and date.month == 2: return date + datetime.timedelta(days = int(years * 365.0)) # Leap years break calendar years\n    if years == int(years): return date.replace( year = date.year + int(years))\n    return date + datetime.timedelta(days = int(years * 365.0))\n\ndef add_days(date, nodays = 1):\n    \"\"\"\n    Adds days to a date, returning a new datetime\n    \"\"\"\n    if date is None: return None\n    return date + datetime.timedelta(days = nodays)\n\ndef add_hours(date, nohours = 1):\n    \"\"\"\n    Add hours to date, returning a new datetime\n    \"\"\"\n    if date is None: return None\n    return date + datetime.timedelta(hours = nohours)\n\ndef add_minutes(date, nomins = 1):\n    \"\"\"\n    Add mins to date, returning a new datetime\n    \"\"\"\n    if date is None: return None\n    return date + datetime.timedelta(minutes = nomins)\n\ndef add_seconds(date, nosecs = 1):\n    \"\"\"\n    Add secs to date, returning a new datetime\n    \"\"\"\n    if date is None: return None\n    return date + datetime.timedelta(seconds = nosecs)\n\ndef subtract_seconds(date, nosecs = 1):\n    \"\"\"\n    Subtract seconds from date, returning a new datetime\n    \"\"\"\n    if date is None: return None\n    return date - datetime.timedelta(seconds = nosecs)\n\ndef subtract_minutes(date, nomins = 1):\n    \"\"\"\n    Subtract minutes from date, returning a new datetime\n    \"\"\"\n    if date is None: return None\n    return date - datetime.timedelta(minutes = nomins)\n\ndef subtract_hours(date, nohours = 1):\n    \"\"\"\n    Subtract hours from date, returning a new datetime\n    \"\"\"\n    if date is None: return None\n    return date - datetime.timedelta(hours = nohours)\n\ndef subtract_days(date, nodays = 1):\n    \"\"\"\n    Subtract days from date, returning a new datetime\n    \"\"\"\n    if date is None: return None\n    return date - datetime.timedelta(days = nodays)\n\ndef subtract_years(date, years = 1.0):\n    \"\"\"\n    Subtracts years from date, returning a new datetime\n    \"\"\"\n    if date is None: return None\n    if date.day == 29 and date.month == 2: return date - datetime.timedelta(days = int(years * 365.0)) # Leap years break calendar years\n    if years == int(years): return date.replace( year = date.year - int(years)) # Go back a calendar year if it's a whole year\n    return date - datetime.timedelta(days = int(years * 365.0))\n\ndef subtract_months(date, months = 1):\n    \"\"\"\n    Subtracts months from a date. Will not work after 11 months.\n    \"\"\"\n    def subtract_one_month(t):\n        one_day = datetime.timedelta(days=1)\n        one_month_earlier = t - one_day\n        while one_month_earlier.month == t.month or one_month_earlier.day > t.day:\n            one_month_earlier -= one_day\n        return one_month_earlier\n    for dummy in range(0, months):\n        date = subtract_one_month(date)\n    return date\n    #year, month = divmod(months, 12)\n    #if date.month <= month:\n    #    year = date.year - 1\n    #    month = date.month - month + 12\n    #else:\n    #    year = date.year \n    #    month = date.month - month\n    #return date.replace(year = year, month = month)\n\ndef monday_of_week(date):\n    \"\"\"\n    Returns the monday of the current week of date.\n    \"\"\"\n    if date is None: return None\n    while True:\n        if date.weekday() == 0:\n            return date\n        date = subtract_days(date, 1)\n\ndef sunday_of_week(date):\n    \"\"\"\n    Returns the sunday of the current week of date.\n    \"\"\"\n    if date is None: return None\n    while True:\n        if date.weekday() == 6:\n            return date\n        date = add_days(date, 1)\n\ndef first_of_month(date):\n    \"\"\"\n    Returns the first of the current month of date.\n    \"\"\"\n    return date.replace(day = 1)\n\ndef first_of_year(date):\n    \"\"\"\n    Returns the first of the current year.\n    \"\"\"\n    return date.replace(day = 1, month = 1)\n\ndef last_of_month(date):\n    \"\"\"\n    Returns the last of the current month of date.\n    \"\"\"\n    date = add_months(date, 1)\n    date = first_of_month(date)\n    return subtract_days(date, 1)\n\ndef last_of_year(date):\n    \"\"\"\n    Returns the last of the current year of date.\n    \"\"\"\n    date = add_years(date, 1)\n    date = first_of_year(date)\n    return subtract_days(date, 1)\n\ndef after(date1, date2):\n    \"\"\"\n    returns true if date1 is after date2\n    \"\"\"\n    return date_diff_days(date1, date2) < 0\n\ndef date_diff_days(date1, date2):\n    \"\"\"\n    Returns the difference in days between two dates. It's\n    assumed that date2 > date1. We aren't using subtraction\n    for timedeltas because it doesn't seem to work correctly\n    when subtracting date from datetime (and some items\n    in the database come through as date). Instead, we convert\n    to unix time to calculate.\n    (datetime) date1\n    (datetime) date2\n    \"\"\"\n    if date1 is None or date2 is None: return 0\n    try:\n        ux1 = time.mktime(date1.timetuple())\n        ux2 = time.mktime(date2.timetuple())\n        delta = int((ux2 - ux1) / 60 / 60 / 24)\n        return delta\n    except:\n        return 0\n\ndef date_diff(l, date1, date2, cutoffs = \"7|182|365\"):\n    \"\"\"\n    Returns a string representing the difference between two\n    dates. Eg: 6 weeks, 5 months.\n    It is expected that date2 > date1\n    (datetime) date1\n    (datetime) date2\n    \"\"\"\n    days = int(date_diff_days(date1, date2))\n    return format_diff(l, days, cutoffs)\n\ndef format_diff(l, days, cutoffs = \"7|182|365\"):\n    \"\"\"\n    Returns a formatted diff from a number of days.\n    Eg: 6 weeks, 5 months.\n    \"\"\"\n    if days is None or days < 0: days = 0\n    weeks = int(days / 7)\n    months = int(days / 30.5)\n    years = int(days / 365)\n   \n    # If it's less than a week, show as days\n    if days < cint(cutoffs.split(\"|\")[0]):\n        return ntranslate(days, [ _(\"{plural0} day.\", l), _(\"{plural1} days.\", l), _(\"{plural2} days.\", l), _(\"{plural3} days.\")], l)\n    # If it's 26 weeks or less, show as weeks\n    elif days < cint(cutoffs.split(\"|\")[1]):\n        return ntranslate(weeks, [ _(\"{plural0} week.\", l), _(\"{plural1} weeks.\", l), _(\"{plural2} weeks.\", l), _(\"{plural3} weeks.\")], l)\n    # If it's less than a year, show as months\n    elif days < cint(cutoffs.split(\"|\")[2]):\n        return ntranslate(months, [ _(\"{plural0} month.\", l), _(\"{plural1} months.\", l), _(\"{plural2} months.\", l), _(\"{plural3} months.\")], l)\n    else:\n        # Show as years and months\n        months = int((days % 365) / 30.5)\n        return ntranslate(years, [ _(\"{plural0} year.\", l), _(\"{plural1} years.\", l), _(\"{plural2} years.\", l), _(\"{plural3} years.\")], l).replace(\".\", \"\") + \\\n            \" \" + ntranslate(months, [ _(\"{plural0} month.\", l), _(\"{plural1} months.\", l), _(\"{plural2} months.\", l), _(\"{plural3} months.\")], l)\n\ndef parse_dst(c):\n    \"\"\"\n    Parses dst code c and returns values for day of week,\n    start offset in month, start month, end offset in month, end month\n    \"\"\"\n    dow, start, end = c.split(\"-\")\n    return (int(dow), start[0], int(start[1:]), end[0], int(end[1:]))\n\ndef dst_find_day(dow, x, month, yearoffset=0):\n    \"\"\" \n    Finds the xth dow in month this year.\n    dow: int day of the week (0 = mon, 6 = sun)\n    x: which day to find, 1-5 or L for the last dow in the month\n    month: int the month we're looking in\n    yearoffset: add to the current year\n    \"\"\"\n    d = today()\n    if yearoffset > 0: d = add_years(d, yearoffset)\n    d = d.replace(month=month, day=1)\n    if x == \"L\":\n        # Looking for the last dow in month\n        d = last_of_month(d)\n        while d.day > 20:\n            if d.weekday() == dow: break\n            d = subtract_days(d, 1)\n    else:\n        # Looking for X dow in month\n        found = 0\n        while d.month == month:\n            if d.weekday() == dow: found += 1\n            if found == int(x): break\n            d = add_days(d, 1)\n    return d\n\ndef dst_start_date(l):\n    \"\"\" Calculates the dst start date/time for locale \"\"\"\n    dow, so, sm, dummy, dummy = parse_dst(get_dst(l))\n    return dst_find_day( dow, so, sm)\n\ndef dst_end_date(l):\n    \"\"\" Calculates the dst end date/time for locale \"\"\"\n    dow, dummy, sm, eo, em = parse_dst(get_dst(l))\n    return dst_find_day(dow, eo, em, sm > em and 1 or 0) # set 1 year offset if start month is later than end month\n\ndef dst_adjust(l, offset = 0.0):\n    \"\"\"\n    Returns 1 if locale l is currently in daylight savings time.\n    offset: Included so that the time now without dst can be calculated first to\n            decide whether or not we're in dst (otherwise we could be wrong for a day)\n    You can add this call to a timezone offset to get the correct adjustment.\n    \"\"\"\n    c = get_dst(l)\n    if c == \"\": return 0 # No dst information for this locale, no adjustment\n    d = now(offset)\n    dsts = dst_start_date(l)\n    dste = dst_end_date(l)\n    if d >= dsts and d <= dste: return 1 # we're in dst\n    return 0\n\ndef now(offset = 0.0):\n    \"\"\"\n    Returns a python date representing now\n    offset: A UTC offset to apply in hours\n    \"\"\"\n    if offset < 0:\n        return datetime.datetime.now() - datetime.timedelta(hours = abs(offset))\n    else:\n        return datetime.datetime.now() + datetime.timedelta(hours = offset)\n\ndef today():\n    \"\"\"\n    Returns a python datetime set to today, but with time information at midnight.\n    \"\"\"\n    d = datetime.datetime.now()\n    return datetime.datetime(d.year, d.month, d.day)\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/asm3/i18n.py b/src/asm3/i18n.py
--- a/src/asm3/i18n.py	
+++ b/src/asm3/i18n.py	
@@ -6,8 +6,8 @@
 # flake8: noqa - we have a lot of locales and this is convenient
 from asm3.locales import *
 
-VERSION = "46u [Fri 22 Jul 2022 15:44:58 IDT]"
-BUILD = "07221544"
+VERSION = "46u [Mon 25 Jul 2022 23:02:36 IDT]"
+BUILD = "07252302"
 
 DMY = ( "%d/%m/%Y", "%d/%m/%y" )
 HDMY = ( "%d-%m-%Y", "%d-%m-%y" )
Index: src/web062/application.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\nWeb application\n(from web.py)\n\"\"\"\n\nimport itertools\nimport os\nimport sys\nimport traceback\nimport wsgiref.handlers\nfrom inspect import isclass\nfrom io import BytesIO\n\nfrom . import browser, httpserver, utils\nfrom . import webapi as web\nfrom . import wsgi\nfrom .debugerror import debugerror\nfrom .py3helpers import iteritems\nfrom .utils import lstrips\n\nfrom urllib.parse import urlparse, urlencode, unquote\n\nfrom importlib import reload\n\n\n__all__ = [\n    \"application\",\n    \"auto_application\",\n    \"subdir_application\",\n    \"subdomain_application\",\n    \"loadhook\",\n    \"unloadhook\",\n    \"autodelegate\",\n]\n\n\nclass application:\n    \"\"\"\n    Application to delegate requests based on path.\n\n        >>> urls = (\"/hello\", \"hello\")\n        >>> app = application(urls, globals())\n        >>> class hello:\n        ...     def GET(self): return \"hello\"\n        >>>\n        >>> app.request(\"/hello\").data\n        'hello'\n    \"\"\"\n\n    # PY3DOCTEST: b'hello'\n\n    def __init__(self, mapping=(), fvars={}, autoreload=None):\n        if autoreload is None:\n            autoreload = web.config.get(\"debug\", False)\n        self.init_mapping(mapping)\n        self.fvars = fvars\n        self.processors = []\n\n        self.add_processor(loadhook(self._load))\n        self.add_processor(unloadhook(self._unload))\n\n        if autoreload:\n\n            def main_module_name():\n                mod = sys.modules[\"__main__\"]\n                file = getattr(\n                    mod, \"__file__\", None\n                )  # make sure this works even from python interpreter\n                return file and os.path.splitext(os.path.basename(file))[0]\n\n            def modname(fvars):\n                \"\"\"find name of the module name from fvars.\"\"\"\n                file, name = fvars.get(\"__file__\"), fvars.get(\"__name__\")\n                if file is None or name is None:\n                    return None\n\n                if name == \"__main__\":\n                    # Since the __main__ module can't be reloaded, the module has\n                    # to be imported using its file name.\n                    name = main_module_name()\n                return name\n\n            mapping_name = utils.dictfind(fvars, mapping)\n            module_name = modname(fvars)\n\n            def reload_mapping():\n                \"\"\"loadhook to reload mapping and fvars.\"\"\"\n                mod = __import__(module_name, None, None, [\"\"])\n                mapping = getattr(mod, mapping_name, None)\n                if mapping:\n                    self.fvars = mod.__dict__\n                    self.init_mapping(mapping)\n\n            self.add_processor(loadhook(Reloader()))\n            if mapping_name and module_name:\n                # when app is ran as part of a package, this puts the app into\n                # `sys.modules` correctly, otherwise the first change to the\n                # app module will not be picked up by Reloader\n                # RRT: 26/10/2021 - THIS BREAKS SESSIONS BY RELOADING\n                # THE PROCESSOR LIST, WHICH REMOVES Session._processor()\n                # reload_mapping()\n                self.add_processor(loadhook(reload_mapping))\n\n            # load __main__ module usings its filename, so that it can be reloaded.\n            if main_module_name() and \"__main__\" in sys.argv:\n                try:\n                    __import__(main_module_name())\n                except ImportError:\n                    pass\n\n    def _load(self):\n        web.ctx.app_stack.append(self)\n\n    def _unload(self):\n        web.ctx.app_stack = web.ctx.app_stack[:-1]\n\n        if web.ctx.app_stack:\n            # this is a sub-application, revert ctx to earlier state.\n            oldctx = web.ctx.get(\"_oldctx\")\n            if oldctx:\n                web.ctx.home = oldctx.home\n                web.ctx.homepath = oldctx.homepath\n                web.ctx.path = oldctx.path\n                web.ctx.fullpath = oldctx.fullpath\n\n    def _cleanup(self):\n        # Threads can be recycled by WSGI servers.\n        # Clearing up all thread-local state to avoid interefereing with subsequent requests.\n        utils.ThreadedDict.clear_all()\n\n    def init_mapping(self, mapping):\n        self.mapping = list(utils.group(mapping, 2))\n\n    def add_mapping(self, pattern, classname):\n        self.mapping.append((pattern, classname))\n\n    def add_processor(self, processor):\n        \"\"\"\n        Adds a processor to the application.\n\n            >>> urls = (\"/(.*)\", \"echo\")\n            >>> app = application(urls, globals())\n            >>> class echo:\n            ...     def GET(self, name): return name\n            ...\n            >>>\n            >>> def hello(handler): return \"hello, \" +  handler()\n            ...\n            >>> app.add_processor(hello)\n            >>> app.request(\"/web.py\").data\n            'hello, web.py'\n        \"\"\"\n        # PY3DOCTEST: b'hello, web.py'\n        self.processors.append(processor)\n\n    def request(\n        self,\n        localpart=\"/\",\n        method=\"GET\",\n        data=None,\n        host=\"0.0.0.0:8080\",\n        headers=None,\n        https=False,\n        **kw\n    ):\n        \"\"\"Makes request to this application for the specified path and method.\n        Response will be a storage object with data, status and headers.\n\n            >>> urls = (\"/hello\", \"hello\")\n            >>> app = application(urls, globals())\n            >>> class hello:\n            ...     def GET(self):\n            ...         web.header('Content-Type', 'text/plain')\n            ...         return \"hello\"\n            ...\n            >>> response = app.request(\"/hello\")\n            >>> response.data\n            'hello'\n            >>> response.status\n            '200 OK'\n            >>> response.headers['Content-Type']\n            'text/plain'\n\n        To use https, use https=True.\n\n            >>> urls = (\"/redirect\", \"redirect\")\n            >>> app = application(urls, globals())\n            >>> class redirect:\n            ...     def GET(self): raise web.seeother(\"/foo\")\n            ...\n            >>> response = app.request(\"/redirect\")\n            >>> response.headers['Location']\n            'http://0.0.0.0:8080/foo'\n            >>> response = app.request(\"/redirect\", https=True)\n            >>> response.headers['Location']\n            'https://0.0.0.0:8080/foo'\n\n        The headers argument specifies HTTP headers as a mapping object\n        such as a dict.\n\n            >>> urls = ('/ua', 'uaprinter')\n            >>> class uaprinter:\n            ...     def GET(self):\n            ...         return 'your user-agent is ' + web.ctx.env['HTTP_USER_AGENT']\n            ...\n            >>> app = application(urls, globals())\n            >>> app.request('/ua', headers = {\n            ...      'User-Agent': 'a small jumping bean/1.0 (compatible)'\n            ... }).data\n            'your user-agent is a small jumping bean/1.0 (compatible)'\n\n        \"\"\"\n        # PY3DOCTEST: b'hello'\n        # PY3DOCTEST: b'your user-agent is a small jumping bean/1.0 (compatible)'\n        _p = urlparse(localpart)\n        path = _p.path\n        maybe_query = _p.query\n\n        query = maybe_query or \"\"\n\n        if \"env\" in kw:\n            env = kw[\"env\"]\n        else:\n            env = {}\n        env = dict(\n            env,\n            HTTP_HOST=host,\n            REQUEST_METHOD=method,\n            PATH_INFO=path,\n            QUERY_STRING=query,\n            HTTPS=str(https),\n        )\n        headers = headers or {}\n\n        for k, v in headers.items():\n            env[\"HTTP_\" + k.upper().replace(\"-\", \"_\")] = v\n\n        if \"HTTP_CONTENT_LENGTH\" in env:\n            env[\"CONTENT_LENGTH\"] = env.pop(\"HTTP_CONTENT_LENGTH\")\n\n        if \"HTTP_CONTENT_TYPE\" in env:\n            env[\"CONTENT_TYPE\"] = env.pop(\"HTTP_CONTENT_TYPE\")\n\n        if method not in [\"HEAD\", \"GET\"]:\n            data = data or \"\"\n\n            if isinstance(data, dict):\n                q = urlencode(data)\n            else:\n                q = data\n\n            env[\"wsgi.input\"] = BytesIO(q.encode(\"utf-8\"))\n            # if not env.get('CONTENT_TYPE', '').lower().startswith('multipart/') and 'CONTENT_LENGTH' not in env:\n            if \"CONTENT_LENGTH\" not in env:\n                env[\"CONTENT_LENGTH\"] = len(q)\n        response = web.storage()\n\n        def start_response(status, headers):\n            response.status = status\n            response.headers = dict(headers)\n            response.header_items = headers\n\n        data = self.wsgifunc()(env, start_response)\n        response.data = b\"\".join(data)\n        return response\n\n    def browser(self):\n        return browser.AppBrowser(self)\n\n    def handle(self):\n        fn, args = self._match(self.mapping, web.ctx.path)\n        return self._delegate(fn, self.fvars, args)\n\n    def handle_with_processors(self):\n        def process(processors):\n            try:\n                if processors:\n                    p, processors = processors[0], processors[1:]\n                    return p(lambda: process(processors))\n                else:\n                    return self.handle()\n            except web.HTTPError:\n                raise\n            except (KeyboardInterrupt, SystemExit):\n                raise\n            except:\n                print(traceback.format_exc(), file=web.debug)\n                raise self.internalerror()\n\n        # processors must be applied in the reverse order. (??)\n        return process(self.processors)\n\n    def wsgifunc(self, *middleware):\n        \"\"\"Returns a WSGI-compatible function for this application.\"\"\"\n\n        def peep(iterator):\n            \"\"\"Peeps into an iterator by doing an iteration\n            and returns an equivalent iterator.\n            \"\"\"\n            # wsgi requires the headers first\n            # so we need to do an iteration\n            # and save the result for later\n            try:\n                firstchunk = next(iterator)\n            except StopIteration:\n                firstchunk = \"\"\n\n            return itertools.chain([firstchunk], iterator)\n\n        def wsgi(env, start_resp):\n            # clear threadlocal to avoid inteference of previous requests\n            self._cleanup()\n\n            self.load(env)\n            try:\n                # allow uppercase methods only\n                if web.ctx.method.upper() != web.ctx.method:\n                    raise web.nomethod()\n\n                result = self.handle_with_processors()\n                if result and hasattr(result, \"__next__\"):\n                    result = peep(result)\n                else:\n                    result = [result]\n            except web.HTTPError as e:\n                result = [e.data]\n\n            def build_result(result):\n                for r in result:\n                    if isinstance(r, bytes):\n                        yield r\n                    else:\n                        yield str(r).encode(\"utf-8\")\n\n            result = build_result(result)\n\n            status, headers = web.ctx.status, web.ctx.headers\n            start_resp(status, headers)\n\n            def cleanup():\n                self._cleanup()\n                yield b\"\"  # force this function to be a generator\n\n            return itertools.chain(result, cleanup())\n\n        for m in middleware:\n            wsgi = m(wsgi)\n\n        return wsgi\n\n    def run(self, *middleware):\n        \"\"\"\n        Starts handling requests. If called in a CGI or FastCGI context, it will follow\n        that protocol. If called from the command line, it will start an HTTP\n        server on the port named in the first command line argument, or, if there\n        is no argument, on port 8080.\n\n        `middleware` is a list of WSGI middleware which is applied to the resulting WSGI\n        function.\n        \"\"\"\n        return wsgi.runwsgi(self.wsgifunc(*middleware))\n\n    def stop(self):\n        \"\"\"Stops the http server started by run.\"\"\"\n        if httpserver.server:\n            httpserver.server.stop()\n            httpserver.server = None\n\n    def cgirun(self, *middleware):\n        \"\"\"\n        Return a CGI handler. This is mostly useful with Google App Engine.\n        There you can just do:\n\n            main = app.cgirun()\n        \"\"\"\n        wsgiapp = self.wsgifunc(*middleware)\n\n        try:\n            from google.appengine.ext.webapp.util import run_wsgi_app\n\n            return run_wsgi_app(wsgiapp)\n        except ImportError:\n            # we're not running from within Google App Engine\n            return wsgiref.handlers.CGIHandler().run(wsgiapp)\n\n    def gaerun(self, *middleware):\n        \"\"\"\n        Starts the program in a way that will work with Google app engine,\n        no matter which version you are using (2.5 / 2.7)\n\n        If it is 2.5, just normally start it with app.gaerun()\n\n        If it is 2.7, make sure to change the app.yaml handler to point to the\n        global variable that contains the result of app.gaerun()\n\n        For example:\n\n        in app.yaml (where code.py is where the main code is located)\n\n            handlers:\n            - url: /.*\n              script: code.app\n\n        Make sure that the app variable is globally accessible\n        \"\"\"\n        wsgiapp = self.wsgifunc(*middleware)\n        try:\n            # check what version of python is running\n            version = sys.version_info[:2]\n            major = version[0]\n            minor = version[1]\n\n            if major != 2:\n                raise EnvironmentError(\n                    \"Google App Engine only supports python 2.5 and 2.7\"\n                )\n\n            # if 2.7, return a function that can be run by gae\n            if minor == 7:\n                return wsgiapp\n            # if 2.5, use run_wsgi_app\n            elif minor == 5:\n                from google.appengine.ext.webapp.util import run_wsgi_app\n\n                return run_wsgi_app(wsgiapp)\n            else:\n                raise EnvironmentError(\n                    \"Not a supported platform, use python 2.5 or 2.7\"\n                )\n        except ImportError:\n            return wsgiref.handlers.CGIHandler().run(wsgiapp)\n\n    def load(self, env):\n        \"\"\"Initializes ctx using env.\"\"\"\n        ctx = web.ctx\n        ctx.clear()\n        ctx.status = \"200 OK\"\n        ctx.headers = []\n        ctx.output = \"\"\n        ctx.environ = ctx.env = env\n        ctx.host = env.get(\"HTTP_HOST\")\n\n        if env.get(\"wsgi.url_scheme\") in [\"http\", \"https\"]:\n            ctx.protocol = env[\"wsgi.url_scheme\"]\n        elif env.get(\"HTTPS\", \"\").lower() in [\"on\", \"true\", \"1\"]:\n            ctx.protocol = \"https\"\n        else:\n            ctx.protocol = \"http\"\n        ctx.homedomain = ctx.protocol + \"://\" + env.get(\"HTTP_HOST\", \"[unknown]\")\n        ctx.homepath = os.environ.get(\"REAL_SCRIPT_NAME\", env.get(\"SCRIPT_NAME\", \"\"))\n        ctx.home = ctx.homedomain + ctx.homepath\n        # @@ home is changed when the request is handled to a sub-application.\n        # @@ but the real home is required for doing absolute redirects.\n        ctx.realhome = ctx.home\n        ctx.ip = env.get(\"REMOTE_ADDR\")\n        ctx.method = env.get(\"REQUEST_METHOD\")\n        try:\n            ctx.path = bytes(env.get(\"PATH_INFO\"), \"latin1\").decode(\"utf8\")\n        except UnicodeDecodeError:  # If there are Unicode characters...\n            ctx.path = env.get(\"PATH_INFO\")\n\n        # http://trac.lighttpd.net/trac/ticket/406 requires:\n        if env.get(\"SERVER_SOFTWARE\", \"\").startswith((\"lighttpd/\", \"nginx/\")):\n            ctx.path = lstrips(env.get(\"REQUEST_URI\").split(\"?\")[0], ctx.homepath)\n            # Apache and CherryPy webservers unquote urls but lighttpd and nginx do not.\n            # Unquote explicitly for lighttpd and nginx to make ctx.path uniform across\n            # all servers.\n            ctx.path = unquote(ctx.path)\n\n        if env.get(\"QUERY_STRING\"):\n            ctx.query = \"?\" + env.get(\"QUERY_STRING\", \"\")\n        else:\n            ctx.query = \"\"\n\n        ctx.fullpath = ctx.path + ctx.query\n\n        for k, v in iteritems(ctx):\n            # convert all string values to unicode values and replace\n            # malformed data with a suitable replacement marker.\n            if isinstance(v, bytes):\n                ctx[k] = v.decode(\"utf-8\", \"replace\")\n\n        # status must always be str\n        ctx.status = \"200 OK\"\n\n        ctx.app_stack = []\n\n    def _delegate(self, f, fvars, args=[]):\n        def handle_class(cls):\n            meth = web.ctx.method\n            if meth == \"HEAD\" and not hasattr(cls, meth):\n                meth = \"GET\"\n            if not hasattr(cls, meth):\n                raise web.nomethod(cls)\n            tocall = getattr(cls(), meth)\n            return tocall(*args)\n\n        if f is None:\n            raise web.notfound()\n        elif isinstance(f, application):\n            return f.handle_with_processors()\n        elif isclass(f):\n            return handle_class(f)\n        elif isinstance(f, str):\n            if f.startswith(\"redirect \"):\n                url = f.split(\" \", 1)[1]\n                if web.ctx.method == \"GET\":\n                    x = web.ctx.env.get(\"QUERY_STRING\", \"\")\n                    if x:\n                        url += \"?\" + x\n                raise web.redirect(url)\n            elif \".\" in f:\n                mod, cls = f.rsplit(\".\", 1)\n                mod = __import__(mod, None, None, [\"\"])\n                cls = getattr(mod, cls)\n            else:\n                cls = fvars[f]\n            return handle_class(cls)\n        elif hasattr(f, \"__call__\"):\n            return f()\n        else:\n            return web.notfound()\n\n    def _match(self, mapping, value):\n        for pat, what in mapping:\n            if isinstance(what, application):\n                if value.startswith(pat):\n                    f = lambda: self._delegate_sub_application(pat, what)\n                    return f, None\n                else:\n                    continue\n            elif isinstance(what, str):\n                what, result = utils.re_subm(r\"^%s\\Z\" % (pat,), what, value)\n            else:\n                result = utils.re_compile(r\"^%s\\Z\" % (pat,)).match(value)\n\n            if result:  # it's a match\n                return what, [x for x in result.groups()]\n        return None, None\n\n    def _delegate_sub_application(self, dir, app):\n        \"\"\"Deletes request to sub application `app` rooted at the directory `dir`.\n        The home, homepath, path and fullpath values in web.ctx are updated to mimic request\n        to the subapp and are restored after it is handled.\n\n        @@Any issues with when used with yield?\n        \"\"\"\n        web.ctx._oldctx = web.storage(web.ctx)\n        web.ctx.home += dir\n        web.ctx.homepath += dir\n        web.ctx.path = web.ctx.path[len(dir) :]\n        web.ctx.fullpath = web.ctx.fullpath[len(dir) :]\n        return app.handle_with_processors()\n\n    def get_parent_app(self):\n        if self in web.ctx.app_stack:\n            index = web.ctx.app_stack.index(self)\n            if index > 0:\n                return web.ctx.app_stack[index - 1]\n\n    def notfound(self):\n        \"\"\"Returns HTTPError with '404 not found' message\"\"\"\n        parent = self.get_parent_app()\n        if parent:\n            return parent.notfound()\n        else:\n            return web._NotFound()\n\n    def internalerror(self):\n        \"\"\"Returns HTTPError with '500 internal error' message\"\"\"\n        parent = self.get_parent_app()\n        if parent:\n            return parent.internalerror()\n        elif web.config.get(\"debug\"):\n            return debugerror()\n        else:\n            return web._InternalError()\n\n\ndef with_metaclass(mcls):\n    def decorator(cls):\n        body = vars(cls).copy()\n        # clean out class body\n        body.pop(\"__dict__\", None)\n        body.pop(\"__weakref__\", None)\n        return mcls(cls.__name__, cls.__bases__, body)\n\n    return decorator\n\n\nclass auto_application(application):\n    \"\"\"Application similar to `application` but urls are constructed\n    automatically using metaclass.\n\n        >>> app = auto_application()\n        >>> class hello(app.page):\n        ...     def GET(self): return \"hello, world\"\n        ...\n        >>> class foo(app.page):\n        ...     path = '/foo/.*'\n        ...     def GET(self): return \"foo\"\n        >>> app.request(\"/hello\").data\n        'hello, world'\n        >>> app.request('/foo/bar').data\n        'foo'\n    \"\"\"\n\n    # PY3DOCTEST: b'hello, world'\n    # PY3DOCTEST: b'foo'\n\n    def __init__(self):\n        application.__init__(self)\n\n        class metapage(type):\n            def __init__(klass, name, bases, attrs):\n                type.__init__(klass, name, bases, attrs)\n                path = attrs.get(\"path\", \"/\" + name)\n\n                # path can be specified as None to ignore that class\n                # typically required to create a abstract base class.\n                if path is not None:\n                    self.add_mapping(path, klass)\n\n        @with_metaclass(metapage)  # little hack needed for Py2 and Py3 compatibility\n        class page:\n            path = None\n\n        self.page = page\n\n\n# The application class already has the required functionality of subdir_application\nsubdir_application = application\n\n\nclass subdomain_application(application):\n    r\"\"\"\n    Application to delegate requests based on the host.\n\n        >>> urls = (\"/hello\", \"hello\")\n        >>> app = application(urls, globals())\n        >>> class hello:\n        ...     def GET(self): return \"hello\"\n        >>>\n        >>> mapping = (r\"hello\\.example\\.com\", app)\n        >>> app2 = subdomain_application(mapping)\n        >>> app2.request(\"/hello\", host=\"hello.example.com\").data\n        'hello'\n        >>> response = app2.request(\"/hello\", host=\"something.example.com\")\n        >>> response.status\n        '404 Not Found'\n        >>> response.data\n        'not found'\n    \"\"\"\n\n    # PY3DOCTEST: b'hello'\n    # PY3DOCTEST: b'not found'\n\n    def handle(self):\n        host = web.ctx.host.split(\":\")[0]  # strip port\n        fn, args = self._match(self.mapping, host)\n        return self._delegate(fn, self.fvars, args)\n\n    def _match(self, mapping, value):\n        for pat, what in mapping:\n            if isinstance(what, str):\n                what, result = utils.re_subm(\"^\" + pat + \"$\", what, value)\n            else:\n                result = utils.re_compile(\"^\" + pat + \"$\").match(value)\n\n            if result:  # it's a match\n                return what, [x for x in result.groups()]\n        return None, None\n\n\ndef loadhook(h):\n    \"\"\"\n    Converts a load hook into an application processor.\n\n        >>> app = auto_application()\n        >>> def f(): \"something done before handling request\"\n        ...\n        >>> app.add_processor(loadhook(f))\n    \"\"\"\n\n    def processor(handler):\n        h()\n        return handler()\n\n    return processor\n\n\ndef unloadhook(h):\n    \"\"\"\n    Converts an unload hook into an application processor.\n\n        >>> app = auto_application()\n        >>> def f(): \"something done after handling request\"\n        ...\n        >>> app.add_processor(unloadhook(f))\n    \"\"\"\n\n    def processor(handler):\n        try:\n            result = handler()\n        except:\n            # run the hook even when handler raises some exception\n            h()\n            raise\n\n        if result and hasattr(result, \"__next__\"):\n            return wrap(result)\n        else:\n            h()\n            return result\n\n    def wrap(result):\n        def next_hook():\n            try:\n                return next(result)\n            except:\n                # call the hook at the and of iterator\n                h()\n                raise\n\n        result = iter(result)\n        while True:\n            try:\n                yield next_hook()\n            except StopIteration:\n                return\n\n    return processor\n\n\ndef autodelegate(prefix=\"\"):\n    \"\"\"\n    Returns a method that takes one argument and calls the method named prefix+arg,\n    calling `notfound()` if there isn't one. Example:\n\n        urls = ('/prefs/(.*)', 'prefs')\n\n        class prefs:\n            GET = autodelegate('GET_')\n            def GET_password(self): pass\n            def GET_privacy(self): pass\n\n    `GET_password` would get called for `/prefs/password` while `GET_privacy` for\n    `GET_privacy` gets called for `/prefs/privacy`.\n\n    If a user visits `/prefs/password/change` then `GET_password(self, '/change')`\n    is called.\n    \"\"\"\n\n    def internal(self, arg):\n        if \"/\" in arg:\n            first, rest = arg.split(\"/\", 1)\n            func = prefix + first\n            args = [\"/\" + rest]\n        else:\n            func = prefix + arg\n            args = []\n\n        if hasattr(self, func):\n            try:\n                return getattr(self, func)(*args)\n            except TypeError:\n                raise web.notfound()\n        else:\n            raise web.notfound()\n\n    return internal\n\n\nclass Reloader:\n    \"\"\"Checks to see if any loaded modules have changed on disk and,\n    if so, reloads them.\n    \"\"\"\n\n    \"\"\"File suffix of compiled modules.\"\"\"\n    if sys.platform.startswith(\"java\"):\n        SUFFIX = \"$py.class\"\n    else:\n        SUFFIX = \".pyc\"\n\n    def __init__(self):\n        self.mtimes = {}\n\n    def __call__(self):\n        sys_modules = list(sys.modules.values())\n        for mod in sys_modules:\n            self.check(mod)\n\n    def check(self, mod):\n        # jython registers java packages as modules but they either\n        # don't have a __file__ attribute or its value is None\n        if not (mod and hasattr(mod, \"__file__\") and mod.__file__):\n            return\n\n        try:\n            mtime = os.stat(mod.__file__).st_mtime\n        except (OSError, IOError):\n            return\n        if mod.__file__.endswith(self.__class__.SUFFIX) and os.path.exists(\n            mod.__file__[:-1]\n        ):\n            mtime = max(os.stat(mod.__file__[:-1]).st_mtime, mtime)\n\n        if mod not in self.mtimes:\n            self.mtimes[mod] = mtime\n        elif self.mtimes[mod] < mtime:\n            try:\n                reload(mod)\n                self.mtimes[mod] = mtime\n            except ImportError:\n                pass\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/web062/application.py b/src/web062/application.py
--- a/src/web062/application.py	
+++ b/src/web062/application.py	
@@ -395,7 +395,7 @@
 
         For example:
 
-        in app.yaml (where code.py is where the main code is located)
+        in app.yaml (where code_test.py is where the main code is located)
 
             handlers:
             - url: /.*
Index: src/asm3/sitedefs.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\n\"\"\"\nWARNING: YOU SHOULD NO LONGER EDIT THIS FILE BY HAND!\n======================================================\n\nMake changes at /etc/asm3.conf instead. If you do not have that file, \ncopy it from scripts/asm3.conf.example\n\"\"\"\n\n# Provides site-wide definitions, reading them from a configuration file\nimport codecs, os, sys, json\n\n# The map of values loaded from the config file\ncfg = None\n\ndef read_config_file():\n    \"\"\"\n    Load the config file into cfg map. Looks for the config file in\n    the following places in order:\n    1. ASM3_CONF environment variable\n    2. $INSTALL_DIR/asm3.conf\n    3. $HOME/.asm3.conf\n    4. /etc/asm3.conf\n    \"\"\"\n    global cfg\n    fname = \"\"\n    insconf = os.path.dirname(os.path.abspath(__file__)) + os.sep + \"..\" + os.sep + \"asm3.conf\"\n    homeconf = os.path.expanduser(\"~\") + os.sep + \".asm3.conf\"\n    if \"ASM3_CONF\" in os.environ and os.environ[\"ASM3_CONF\"] != \"\": fname = os.environ[\"ASM3_CONF\"]\n    elif os.path.exists(insconf): fname = insconf\n    elif os.path.exists(homeconf): fname = homeconf\n    elif os.path.exists(\"/etc/asm3.conf\"): fname = \"/etc/asm3.conf\"\n    if fname == \"\":\n        sys.stderr.write(\"no config found, using defaults\\n\")\n        cfg = {}\n    else:\n        sys.stderr.write(\"config: %s\\n\" % fname)\n        cfg = {}\n        with codecs.open(fname, 'r', encoding='utf8') as f:\n            lines = f.readlines()\n        for l in lines:\n            if l.find(\"#\") != -1 and l.find(\"{\") == -1: \n                l = l[0:l.find(\"#\")]\n            if l.find(\"=\") != -1:\n                k, v = l.split(\"=\", 1)\n                cfg[k.strip()] = v.strip()\n\ndef get_string(k, dv = \"\"):\n    global cfg\n    if cfg is None: read_config_file()\n    if k not in cfg: return dv\n    return cfg[k]\n\ndef get_boolean(k, dv = False):\n    v = get_string(k)\n    if v == \"\": return dv\n    return v == \"True\" or v == \"true\"\n\ndef get_integer(k, dv = 0):\n    v = get_string(k)\n    if v == \"\": return dv\n    return int(v)\n\ndef get_dict(k, dv = {}):\n    v = get_string(k)\n    if v == \"\": return dv\n    return json.loads(v)\n\n# The base URL to the ASM installation as seen by the client (should not end with /)\nBASE_URL = get_string(\"base_url\", \"http://localhost:5000\")\n\n# The URL to asm's service endpoint to be shown in online forms screens in particular,\n# but also used by animal_view_adoptable_js to link to animal_view etc\nSERVICE_URL = get_string(\"service_url\", \"http://localhost:5000/service\")\n\n# The language to use before a locale has been configured \n# in the database\nLOCALE = get_string(\"locale\", \"en\")\n\n# The timezone offset to use before one has been configured\n# in the database (+/- server clock offset, NOT UTC)\nTIMEZONE = get_integer(\"timezone\", 0)\n\n# Where ASM directs log output to, one of:\n# stderr  - the standard error stream\n# syslog  - the UNIX syslogger (to LOCAL3 facility)\n# ntevent - the Windows event logger\n# <file>  - The path to a file to log to\nLOG_LOCATION = get_string(\"log_location\", \"syslog\")\n\n# Include debug messages when logging - set to False\n# to disable debug messages\nLOG_DEBUG = get_boolean(\"log_debug\", True)\n\n# Whether to reload the application when the code.py filestamp changes\nAUTORELOAD = get_boolean(\"autoreload\", False)\n\n# Database info\n# MYSQL, POSTGRESQL, SQLITE or DB2\nDB_TYPE = get_string(\"db_type\", \"MYSQL\")\nDB_HOST = get_string(\"db_host\", \"localhost\")\nDB_PORT = get_integer(\"db_port\", 3306)\nDB_USERNAME = get_string(\"db_username\", \"robin\")\nDB_PASSWORD = get_string(\"db_password\", \"robin\")\nDB_NAME = get_string(\"db_name\", \"asm\")\n\n# If you want to maintain compatibility with an ASM2 client\n# accessing your database, setting this will have ASM3\n# update the primarykey table that ASM2 needs\nDB_HAS_ASM2_PK_TABLE = get_boolean(\"db_has_asm2_pk_table\", False)\n\n# If set, all calls to db.execute will be logged to the file\n# named. Use {database} to substitute database name.\nDB_EXEC_LOG = get_string(\"db_exec_log\")\n\n# Produce an EXPLAIN for each query in the log before running it\nDB_EXPLAIN_QUERIES = get_boolean(\"db_explain_queries\", False)\n\n# Record the time taken to run each query\nDB_TIME_QUERIES = get_boolean(\"db_time_queries\", False)\n\n# If DB_TIME_QUERIES is on, only log queries that take longer \n# than X seconds to run (or 0 to log all queries)\nDB_TIME_LOG_OVER = get_integer(\"db_time_log_over\", 0)\n\n# Time out queries that take longer than this (ms) to run\nDB_TIMEOUT = get_integer(\"db_timeout\", 0)\n\n# URLs for ASM services\nURL_NEWS = get_string(\"url_news\", \"https://sheltermanager.com/repo/asm_news.html\")\nURL_REPORTS = get_string(\"url_reports\", \"https://sheltermanager.com/repo/reports.txt\")\n\n# Deployment type, wsgi or fcgi\nDEPLOYMENT_TYPE = get_string(\"deployment_type\", \"wsgi\")\n\n# Whether the session cookie should be secure (only valid for https)\nSESSION_SECURE_COOKIE = get_boolean(\"session_secure_cookie\", False)\n\n# Output debug info on sessions\nSESSION_DEBUG = get_boolean(\"session_debug\", False)\n\n# The Content-Security-Policy header to send, or blank for no policy\n# Include 'nonce-%(nonce)s' in any policy to prevent the bootstrap \n# inline script breaking\nCONTENT_SECURITY_POLICY = get_string(\"content_security_policy\", \"\")\n\n# The host/port that memcached is running on if it is to be used.\n# If memcache is not available, an in memory dictionary will be\n# used instead.\n#MEMCACHED_SERVER = \"127.0.0.1:11211\"\nMEMCACHED_SERVER = get_string(\"memcached_server\", \"\")\n\n# Where to store media files.\n# database - media files are base64 encoded in the dbfs.content db column\n# file - media files are stored in a folder \n# s3 - media files are stored in S3 compatible storage\nDBFS_STORE = get_string(\"dbfs_store\", \"database\")\n\n# DBFS_STORE = file: The folder where media files are stored.\n# It must exist and ASM must have write permissions. It should never end with a /\nDBFS_FILESTORAGE_FOLDER = get_string(\"dbfs_filestorage_folder\", \"/home/robin/tmp/dbfs\")\n\n# DBFS_STORE = s3: The S3 bucket to store media in and credentials/URL\nDBFS_S3_BUCKET = get_string(\"dbfs_s3_bucket\", \"\")\n# DBFS_STORE = s3: Credentials, if these aren't set, $HOME/.aws/credentials or env will be used\nDBFS_S3_ACCESS_KEY_ID = get_string(\"dbfs_s3_access_key_id\", \"\")\nDBFS_S3_SECRET_ACCESS_KEY = get_string(\"dbfs_s3_secret_access_key\", \"\")\n# DBFS_STORE = s3: endpoint URL if you are using an S3 compatible service rather than AWS S3\nDBFS_S3_ENDPOINT_URL = get_string(\"dbfs_s3_endpoint_url\", \"\")\n\n# The directory to use to cache elements on disk. Must already exist\n# as the application will not attempt to create it.\nDISK_CACHE = get_string(\"disk_cache\", \"/tmp/asm_disk_cache\")\n\n# Cache results of the most common, less important queries for\n# a short period (60 seconds) in the disk cache to help performance. \n# These queries include shelterview animals and main screen links) \nCACHE_COMMON_QUERIES = get_boolean(\"cache_common_queries\", False)\n\n# Cache service call responses on the server side according\n# to their max-age headers in the disk cache\nCACHE_SERVICE_RESPONSES = get_boolean(\"cache_service_responses\", False)\n\n# If EMAIL_ERRORS is set to True, all errors from the site\n# are emailed to ADMIN_EMAIL and the user is given a generic\n# error page. If set to False, debug information is output.\nEMAIL_ERRORS = get_boolean(\"email_errors\", False)\nADMIN_EMAIL = get_string(\"admin_email\", \"you@youraddress.com\")\n\n# If ROLLUP_JS is set to True, a single, rolled up and minified\n# javascript file will be sent to the client\nROLLUP_JS = get_boolean(\"rollup_js\", False)\n\n# Only allow hotlinks to the animal_image and extra_image\n# service calls from this domain, or comma separated list of domains\nIMAGE_HOTLINKING_ONLY_FROM_DOMAIN = get_string(\"image_hotlinking_only_from_domain\", \"\")\n\n# Use Transfer-Encoding: chunked for large files. Note that\n# this does not work with mod_wsgi. Turning it off will cause\n# web.py to buffer the output, which can cause problems with\n# dumps of large databases.\nLARGE_FILES_CHUNKED = get_boolean(\"large_files_chunked\", True)\n\n# QR code provider. \"url\" and \"size\" tokens will be substituted\nQR_IMG_SRC = get_string(\"qr_img_src\", \"//chart.googleapis.com/chart?cht=qr&chl=%(url)s&chs=%(size)s\")\n\n# Whether to resize incoming images\nRESIZE_IMAGES_DURING_ATTACH = get_boolean(\"resize_images_during_attach\", True)\nRESIZE_IMAGES_SPEC = get_string(\"resize_images_spec\", \"1024x1024\")\n\n# Shell command to use to compress PDFs\nSCALE_PDF_DURING_ATTACH = get_boolean(\"scale_pdf_during_attach\", False)\nSCALE_PDF_CMD = get_string(\"scale_pdf_cmd\", \"convert -density 120 -quality 60 %(input)s -compress Jpeg %(output)s\")\n#SCALE_PDF_CMD = \"pdftk %(input)s output %(output)s compress\"\n#SCALE_PDF_CMD = \"gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/screen -dNOPAUSE -dQUIET -dBATCH -sOutputFile=%(output)s %(input)s\"\n\n# Shell command to convert HTML to PDF\nHTML_TO_PDF = get_string(\"html_to_pdf\", \"wkhtmltopdf --orientation %(orientation)s %(papersize)s %(input)s %(output)s\")\n#HTML_TO_PDF = \"html2pdf %(input)s %(output)s\"\n\n# Target for viewing an address on a map, {0} is the address\nMAP_LINK = get_string(\"map_link\", \"https://www.openstreetmap.org/search?query={0}\")\n\n# Map provider for rendering maps on the client, can be \"osm\" or \"google\"\nMAP_PROVIDER = get_string(\"map_provider\", \"osm\")\nMAP_PROVIDER_KEY = get_string(\"map_provider_key\", \"\") # For google, the API key to use when making map requests\nOSM_MAP_TILES = get_string(\"osm_map_tiles\", \"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\")\n\nGEO_PROVIDER = get_string(\"geo_provider\", \"nominatim\")  # Geocode provider to use - nominatim or google\nGEO_PROVIDER_KEY = get_string(\"geo_provider_key\", \"\")   # For google, the API key to use when making geocoding requests\nGEO_SMCOM_URL = get_string(\"geo_smcom_url\", \"\")\nGEO_BATCH = get_boolean(\"geo_batch\", False)             # Whether or not to try and lookup geocodes as part of the batch\nGEO_LIMIT = get_integer(\"geo_limit\", 100)               # How many geocodes to lookup as part of the batch\nGEO_LOOKUP_TIMEOUT = get_integer(\"geo_lookup_timeout\", 5) # Timeout in seconds when doing geocode lookups\nGEO_SLEEP_AFTER = get_integer(\"geo_sleep_after\", 1)     # Sleep for seconds after a request to throttle (nominatim has a 1/s limit)\n\n# Enable the database field on login and allow login to multiple databases\nMULTIPLE_DATABASES = get_boolean(\"multiple_databases\", False)\nMULTIPLE_DATABASES_TYPE = get_string(\"multiple_databases_type\", \"map\")\n# { \"alias\": { \"dbtype\": \"MYSQL\", \"host\": \"localhost\", \"port\": 3306, \"username\": \"root\", \"password\": \"root\", \"database\": \"asm\" } }\nMULTIPLE_DATABASES_MAP = get_dict(\"multiple_databases_map\")\n\n# Whether the old HTML/FTP publisher of static files is enabled\nHTMLFTP_PUBLISHER_ENABLED = get_boolean(\"htmlftp_publisher_enabled\", True)\n\n# FTP hosts and URLs for third party publishing services\nADOPTAPET_FTP_HOST = get_string(\"adoptapet_ftp_host\", \"autoupload.adoptapet.com\")\nAKC_REUNITE_BASE_URL = get_string(\"akc_reunite_base_url\", \"\")\nAKC_REUNITE_USER = get_string(\"akc_reunite_user\", \"\")\nAKC_REUNITE_PASSWORD = get_string(\"akc_reunite_password\", \"\")\nANIBASE_BASE_URL = get_string(\"anibase_base_url\", \"\")\nANIBASE_API_USER = get_string(\"anibase_api_user\", \"\")\nANIBASE_API_KEY = get_string(\"anibase_api_key\", \"\")\nFOUNDANIMALS_FTP_HOST = get_string(\"foundanimals_ftp_host\", \"\")\nFOUNDANIMALS_FTP_USER = get_string(\"foundanimals_ftp_user\", \"\")\nFOUNDANIMALS_FTP_PASSWORD = get_string(\"foundanimals_ftp_password\", \"\")\nHELPINGLOSTPETS_FTP_HOST = get_string(\"helpinglostpets_ftp_host\", \"www.helpinglostpets.com\")\nHOMEAGAIN_BASE_URL = get_string(\"homeagain_base_url\", \"\")\nMADDIES_FUND_TOKEN_URL = get_string(\"maddies_fund_token_url\", \"\")\nMADDIES_FUND_UPLOAD_URL = get_string(\"maddies_fund_upload_url\", \"\")\nPETCADEMY_FTP_HOST = get_string(\"petcademy_ftp_host\", \"\")\nPETCADEMY_FTP_USER = get_string(\"petcademy_ftp_user\", \"\")\nPETCADEMY_FTP_PASSWORD = get_string(\"petcademy_ftp_password\", \"\")\nPETFINDER_FTP_HOST = get_string(\"petfinder_ftp_host\", \"members.petfinder.com\")\nPETFINDER_SEND_PHOTOS_BY_FTP = get_boolean(\"petfinder_send_photos_by_ftp\", True)\nPETRESCUE_URL = get_string(\"petrescue_url\", \"\")\nRESCUEGROUPS_FTP_HOST = get_string(\"rescuegroups_ftp_host\", \"ftp.rescuegroups.org\")\nSAVOURLIFE_API_KEY = get_string(\"savourlife_api_key\", \"\")\nSAVOURLIFE_URL = get_string(\"savourlife_url\", \"\")\nSMARTTAG_FTP_HOST = get_string(\"smarttag_ftp_host\", \"ftp.idtag.com\")\nSMARTTAG_FTP_USER = get_string(\"smarttag_ftp_user\", \"\")\nSMARTTAG_FTP_PASSWORD = get_string(\"smarttag_ftp_password\", \"\")\nPETTRAC_UK_POST_URL = get_string(\"pettrac_uk_post_url\", \"https://online.pettrac.com/registration/onlineregistration.aspx\")\nPETLINK_BASE_URL = get_string(\"petlink_base_url\", \"\")\nPETSLOCATED_FTP_HOST = get_string(\"petslocated_ftp_host\", \"ftp.petslocated.com\")\nPETSLOCATED_FTP_USER = get_string(\"petslocated_ftp_user\", \"\")\nPETSLOCATED_FTP_PASSWORD = get_string(\"petslocated_ftp_password\", \"\")\nVETENVOY_US_VENDOR_USERID = get_string(\"vetenvoy_us_vendor_userid\", \"\")\nVETENVOY_US_VENDOR_PASSWORD = get_string(\"vetenvoy_us_vendor_password\", \"\")\nVETENVOY_US_BASE_URL = get_string(\"vetenvoy_us_base_url\", \"\")\nVETENVOY_US_SYSTEM_ID = get_string(\"vetenvoy_us_system_id\", \"20\")\nVETENVOY_US_HOMEAGAIN_RECIPIENTID = get_string(\"vetenvoy_us_homeagain_recipientid\", \"\")\nVETENVOY_US_AKC_REUNITE_RECIPIENTID = get_string(\"vetenvoy_us_akc_reunite_recipientid\", \"\")\n\n# Config for payment processing services\nPAYPAL_VALIDATE_IPN_URL = get_string(\"paypal_validate_ipn_url\", \"\")\n\n# Options available under the share button\nSHARE_BUTTON = get_string(\"share_button\", \"shareweb,sharepic,shareemail\")\n\n# Type of electronic signing device available\nELECTRONIC_SIGNATURES = get_string(\"electronic_signatures\", \"\")\n\n# If you have an emergency notice you'd like displaying on the\n# login and home screens, set a filename here for the content\n# (if the file does not exist or has no content, nothing will\n# be displayed).\nEMERGENCY_NOTICE = get_string(\"emergency_notice\", \"\")\n\n# SMTP_SERVER = { \"sendmail\": False, \"host\": \"mail.yourdomain.com\", \"port\": 25, \"username\": \"userifauth\", \"password\": \"passifauth\", \"usetls\": False }\n# SMTP_SERVER = { \"sendmail\": False, \"host\": \"mail.yourdomain.com\", \"port\": 25, \"username\": \"\", \"password\": \"\", \"usetls\": False }\nSMTP_SERVER = get_dict(\"smtp_server\", { \"sendmail\": True })\n\n# The from address for all outgoing emails. The email address configured\n# in the database will be used as the Reply-To header to avoid\n# any issues with DKIM/SPF/DMARC spoofing\n# substitutions: \n# {organisation} organisation name\n# {database} database name\n# {alias} database alias\nFROM_ADDRESS = get_string(\"from_address\", \"you@yourdomain.com\")\n\n# URLs to access manuals and help documentation\nMANUAL_HTML_URL = get_string(\"manual_html_url\", \"static/pages/manual/index.html\")\nMANUAL_FAQ_URL = get_string(\"manual_faq_url\", \"static/pages/manual/faq.html\")\nMANUAL_PDF_URL = get_string(\"manual_pdf_url\", \"\")\nMANUAL_VIDEO_URL = get_string(\"manual_video_url\", \"\")\n\nSMCOM_PAYMENT_LINK = get_string(\"smcom_payment_link\", \"\")\nSMCOM_LOGIN_URL = get_string(\"smcom_login_url\", \"\")\n\n# Script and css references for dependencies (can be substituted for separate CDN here)\nASMSELECT_CSS = get_string(\"asmselect_css\", 'static/lib/asmselect/1.0.4a/jquery.asmselect.css')\nASMSELECT_JS = get_string(\"asmselect_js\", 'static/lib/asmselect/1.0.4a/jquery.asmselect.js')\nBASE64_JS = get_string(\"base64_js\", 'static/lib/base64/0.3.0/base64.min.js')\nBOOTSTRAP_JS = get_string(\"bootstrap_js\", 'static/lib/bootstrap/5.1.0/js/bootstrap.min.js')\nBOOTSTRAP_CSS = get_string(\"bootstrap_css\", 'static/lib/bootstrap/5.1.0/css/bootstrap.min.css')\nBOOTSTRAP_GRID_CSS = get_string(\"bootstrap_grid_css\", 'static/lib/bootstrap/5.1.0/css/bootstrap-grid.min.css')\nBOOTSTRAP_ICONS_CSS = get_string(\"bootstrap_icons_css\", 'static/lib/bootstrap-icons/1.5.0/bootstrap-icons.css')\nCODEMIRROR_JS = get_string(\"codemirror_js\", 'static/lib/codemirror/5.65.2/lib/codemirror.js')\nCODEMIRROR_CSS = get_string(\"codemirror_css\", 'static/lib/codemirror/5.65.2/lib/codemirror.css')\nCODEMIRROR_BASE = get_string(\"codemirror_base\", 'static/lib/codemirror/5.65.2/')\nFLOT_JS = get_string(\"flot_js\", 'static/lib/flot/0.8.3/jquery.flot.min.js')\nFLOT_PIE_JS = get_string(\"flot_pie_js\", 'static/lib/flot/0.8.3/jquery.flot.pie.min.js')\nFULLCALENDAR_CSS = get_string(\"fullcalendar_css\", 'static/lib/fullcalendar/3.10.2/fullcalendar.min.css')\nFULLCALENDAR_JS = get_string(\"fullcalendar_js\", 'static/lib/fullcalendar/3.10.2/fullcalendar.min.js')\nJQUERY_UI_CSS = get_string(\"jquery_ui_css\", 'static/lib/jqueryui/jquery-ui-themes-1.13.0/themes/%(theme)s/jquery-ui.css')\nJQUERY_UI_JS = get_string(\"jquery_ui_js\", 'static/lib/jqueryui/jquery-ui-1.13.0/jquery-ui.min.js')\nJQUERY_JS = get_string(\"jquery_js\", 'static/lib/jquery/3.6.0/jquery.min.js')\nJQUERY_MOBILE_CSS = get_string(\"jquery_mobile_css\", 'static/lib/jquerymobile/1.4.5/jquery.mobile.min.css')\nJQUERY_MOBILE_JS = get_string(\"jquery_mobile_js\", 'static/lib/jquerymobile/1.4.5/jquery.mobile.min.js')\nJQUERY_MOBILE_JQUERY_JS = get_string(\"jquery_mobile_jquery_js\", 'static/lib/jquery/2.2.4/jquery.min.js')\nLEAFLET_CSS = get_string(\"leaflet_css\", 'static/lib/leaflet/1.3.1/leaflet.css')\nLEAFLET_JS = get_string(\"leaflet_js\", 'static/lib/leaflet/1.3.1/leaflet.js')\nMOMENT_JS = get_string(\"moment_js\", 'static/lib/moment/2.29.1/moment.min.js')\nMOUSETRAP_JS = get_string(\"mousetrap_js\", 'static/lib/mousetrap/1.4.6/mousetrap.min.js')\nPATH_JS = get_string(\"path_js\", 'static/lib/pathjs/0.8.4.smcom/path.min.js')\nSIGNATURE_JS = get_string(\"signature_js\", 'static/lib/signature/1.1.1/jquery.signature.min.js')\nTABLESORTER_CSS = get_string(\"tablesorter_css\", 'static/lib/tablesorter/2.7.12/themes/theme.asm.css')\nTABLESORTER_JS = get_string(\"tablesorter_js\", 'static/lib/tablesorter/2.7.12/jquery.tablesorter.min.js')\nTABLESORTER_WIDGETS_JS = get_string(\"tablesorter_widgets_js\", 'static/lib/tablesorter/2.7.12/jquery.tablesorter.widgets.min.js')\nTIMEPICKER_CSS = get_string(\"timepicker_css\", 'static/lib/timepicker/0.3.3/jquery.ui.timepicker.css')\nTIMEPICKER_JS = get_string(\"timepicker_js\", 'static/lib/timepicker/0.3.3/jquery.ui.timepicker.js')\nTINYMCE_5_JS = get_string(\"tinymce_4_js\", 'static/lib/tinymce/5.5.1/tinymce/js/tinymce/tinymce.min.js')\nTOUCHPUNCH_JS = get_string(\"touchpunch_js\", 'static/lib/touchpunch/0.2.3/jquery.ui.touch-punch.min.js')\n\n# Watermark Settings for adding an animal's name and shelter logo to an image\nWATERMARK_X_OFFSET = get_string(\"watermark_x_offset\", 10)\nWATERMARK_Y_OFFSET = get_string(\"watermark_y_offset\", 10)\nWATERMARK_FONT_FILE = get_string(\"watermark_font_file\", \"/usr/share/fonts/truetype/liberation/LiberationSans-BoldItalic.ttf\")\nWATERMARK_FONT_SHADOWCOLOR = get_string(\"watermark_font_shadowcolor\", \"black\")\nWATERMARK_FONT_FILLCOLOR = get_string(\"watermark_font_fillcolor\", \"white\")\nWATERMARK_FONT_STROKE = get_string(\"watermark_font_stroke\", 3)\nWATERMARK_FONT_OFFSET = get_string(\"watermark_font_offset\", 20)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/asm3/sitedefs.py b/src/asm3/sitedefs.py
--- a/src/asm3/sitedefs.py	
+++ b/src/asm3/sitedefs.py	
@@ -92,7 +92,7 @@
 # to disable debug messages
 LOG_DEBUG = get_boolean("log_debug", True)
 
-# Whether to reload the application when the code.py filestamp changes
+# Whether to reload the application when the code_test.py filestamp changes
 AUTORELOAD = get_boolean("autoreload", False)
 
 # Database info
diff --git a/src/asm3/event.py b/src/asm3/event.py
new file mode 100644
