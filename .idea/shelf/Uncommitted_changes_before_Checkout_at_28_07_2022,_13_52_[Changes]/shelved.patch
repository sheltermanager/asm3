Index: src/web039/application.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\nWeb application\n(from web.py)\n\"\"\"\nfrom __future__ import print_function\n\nfrom . import webapi as web\nfrom . import webapi, wsgi, utils, browser\nfrom .debugerror import debugerror\nfrom . import httpserver\nfrom .utils import lstrips, safeunicode\nfrom .py3helpers import iteritems, string_types, is_iter, PY2, text_type\nimport sys\n\nimport urllib\nimport traceback\nimport itertools\nimport os\nimport types\nfrom inspect import isclass\n\nimport wsgiref.handlers\n\ntry:\n    from urllib.parse import splitquery, urlencode, quote, unquote\nexcept ImportError:\n    from urllib import splitquery, urlencode, quote, unquote\n\ntry:\n    from importlib import reload #Since Py 3.4 reload is in importlib\nexcept ImportError:\n    try:\n        from imp import reload #Since Py 3.0 and before 3.4 reload is in imp\n    except ImportError:\n        pass #Before Py 3.0 reload is a global function\n\nfrom io import BytesIO\n\n\n__all__ = [\n    \"application\", \"auto_application\",\n    \"subdir_application\", \"subdomain_application\",\n    \"loadhook\", \"unloadhook\",\n    \"autodelegate\"\n]\n\nclass application:\n    \"\"\"\n    Application to delegate requests based on path.\n\n        >>> urls = (\"/hello\", \"hello\")\n        >>> app = application(urls, globals())\n        >>> class hello:\n        ...     def GET(self): return \"hello\"\n        >>>\n        >>> app.request(\"/hello\").data\n        b'hello'\n    \"\"\"\n    def __init__(self, mapping=(), fvars={}, autoreload=None):\n        if autoreload is None:\n            autoreload = web.config.get('debug', False)\n        self.init_mapping(mapping)\n        self.fvars = fvars\n        self.processors = []\n\n        self.add_processor(loadhook(self._load))\n        self.add_processor(unloadhook(self._unload))\n\n        if autoreload:\n            def main_module_name():\n                mod = sys.modules['__main__']\n                file = getattr(mod, '__file__', None) # make sure this works even from python interpreter\n                return file and os.path.splitext(os.path.basename(file))[0]\n\n            def modname(fvars):\n                \"\"\"find name of the module name from fvars.\"\"\"\n                file, name = fvars.get('__file__'), fvars.get('__name__')\n                if file is None or name is None:\n                    return None\n\n                if name == '__main__':\n                    # Since the __main__ module can't be reloaded, the module has\n                    # to be imported using its file name.\n                    name = main_module_name()\n                return name\n\n            mapping_name = utils.dictfind(fvars, mapping)\n            module_name = modname(fvars)\n\n            def reload_mapping():\n                \"\"\"loadhook to reload mapping and fvars.\"\"\"\n                mod = __import__(module_name, None, None, [''])\n                mapping = getattr(mod, mapping_name, None)\n                if mapping:\n                    self.fvars = mod.__dict__\n                    self.init_mapping(mapping)\n\n            self.add_processor(loadhook(Reloader()))\n            if mapping_name and module_name:\n                self.add_processor(loadhook(reload_mapping))\n\n            # load __main__ module usings its filename, so that it can be reloaded.\n            if main_module_name() and '__main__' in sys.argv:\n                try:\n                    __import__(main_module_name())\n                except ImportError:\n                    pass\n\n    def _load(self):\n        web.ctx.app_stack.append(self)\n\n    def _unload(self):\n        web.ctx.app_stack = web.ctx.app_stack[:-1]\n\n        if web.ctx.app_stack:\n            # this is a sub-application, revert ctx to earlier state.\n            oldctx = web.ctx.get('_oldctx')\n            if oldctx:\n                web.ctx.home = oldctx.home\n                web.ctx.homepath = oldctx.homepath\n                web.ctx.path = oldctx.path\n                web.ctx.fullpath = oldctx.fullpath\n\n    def _cleanup(self):\n        # Threads can be recycled by WSGI servers.\n        # Clearing up all thread-local state to avoid interefereing with subsequent requests.\n        utils.ThreadedDict.clear_all()\n\n    def init_mapping(self, mapping):\n        self.mapping = list(utils.group(mapping, 2))\n\n    def add_mapping(self, pattern, classname):\n        self.mapping.append((pattern, classname))\n\n    def add_processor(self, processor):\n        \"\"\"\n        Adds a processor to the application.\n\n            >>> urls = (\"/(.*)\", \"echo\")\n            >>> app = application(urls, globals())\n            >>> class echo:\n            ...     def GET(self, name): return name\n            ...\n            >>>\n            >>> def hello(handler): return \"hello, \" +  handler()\n            ...\n            >>> app.add_processor(hello)\n            >>> app.request(\"/web.py\").data\n            b'hello, web.py'\n        \"\"\"\n        self.processors.append(processor)\n\n    def request(self, localpart='/', method='GET', data=None,\n                host=\"0.0.0.0:8080\", headers=None, https=False, **kw):\n        \"\"\"Makes request to this application for the specified path and method.\n        Response will be a storage object with data, status and headers.\n\n            >>> urls = (\"/hello\", \"hello\")\n            >>> app = application(urls, globals())\n            >>> class hello:\n            ...     def GET(self):\n            ...         web.header('Content-Type', 'text/plain')\n            ...         return \"hello\"\n            ...\n            >>> response = app.request(\"/hello\")\n            >>> response.data\n            b'hello'\n            >>> response.status\n            '200 OK'\n            >>> response.headers['Content-Type']\n            'text/plain'\n\n        To use https, use https=True.\n\n            >>> urls = (\"/redirect\", \"redirect\")\n            >>> app = application(urls, globals())\n            >>> class redirect:\n            ...     def GET(self): raise web.seeother(\"/foo\")\n            ...\n            >>> response = app.request(\"/redirect\")\n            >>> response.headers['Location']\n            'http://0.0.0.0:8080/foo'\n            >>> response = app.request(\"/redirect\", https=True)\n            >>> response.headers['Location']\n            'https://0.0.0.0:8080/foo'\n\n        The headers argument specifies HTTP headers as a mapping object\n        such as a dict.\n\n            >>> urls = ('/ua', 'uaprinter')\n            >>> class uaprinter:\n            ...     def GET(self):\n            ...         return 'your user-agent is ' + web.ctx.env['HTTP_USER_AGENT']\n            ...\n            >>> app = application(urls, globals())\n            >>> app.request('/ua', headers = {\n            ...      'User-Agent': 'a small jumping bean/1.0 (compatible)'\n            ... }).data\n            b'your user-agent is a small jumping bean/1.0 (compatible)'\n\n        \"\"\"\n        path, maybe_query = splitquery(localpart)\n        query = maybe_query or \"\"\n\n        if 'env' in kw:\n            env = kw['env']\n        else:\n            env = {}\n        env = dict(env, HTTP_HOST=host, REQUEST_METHOD=method, PATH_INFO=path, QUERY_STRING=query, HTTPS=str(https))\n        headers = headers or {}\n\n        for k, v in headers.items():\n            env['HTTP_' + k.upper().replace('-', '_')] = v\n\n        if 'HTTP_CONTENT_LENGTH' in env:\n            env['CONTENT_LENGTH'] = env.pop('HTTP_CONTENT_LENGTH')\n\n        if 'HTTP_CONTENT_TYPE' in env:\n            env['CONTENT_TYPE'] = env.pop('HTTP_CONTENT_TYPE')\n\n        if method not in [\"HEAD\", \"GET\"]:\n            data = data or ''\n\n            if isinstance(data, dict):\n                q = urlencode(data)\n            else:\n                q = data\n\n            env['wsgi.input'] = BytesIO(q.encode('utf-8'))\n            if 'CONTENT_LENGTH' not in env:\n            #if not env.get('CONTENT_TYPE', '').lower().startswith('multipart/') and 'CONTENT_LENGTH' not in env:\n                env['CONTENT_LENGTH'] = len(q)\n        response = web.storage()\n        def start_response(status, headers):\n            response.status = status\n            response.headers = dict(headers)\n            response.header_items = headers\n\n        data = self.wsgifunc()(env, start_response)\n        response.data = b\"\".join(data)\n        return response\n\n    def browser(self):\n        return browser.AppBrowser(self)\n\n    def handle(self):\n        fn, args = self._match(self.mapping, web.ctx.path)\n        return self._delegate(fn, self.fvars, args)\n\n    def handle_with_processors(self):\n        def process(processors):\n            try:\n                if processors:\n                    p, processors = processors[0], processors[1:]\n                    return p(lambda: process(processors))\n                else:\n                    return self.handle()\n            except web.HTTPError:\n                raise\n            except (KeyboardInterrupt, SystemExit):\n                raise\n            except:\n                print(traceback.format_exc(), file=web.debug)\n                raise self.internalerror()\n\n        # processors must be applied in the resvere order. (??)\n        return process(self.processors)\n\n    def wsgifunc(self, *middleware):\n        \"\"\"Returns a WSGI-compatible function for this application.\"\"\"\n        def peep(iterator):\n            \"\"\"Peeps into an iterator by doing an iteration\n            and returns an equivalent iterator.\n            \"\"\"\n            # wsgi requires the headers first\n            # so we need to do an iteration\n            # and save the result for later\n            try:\n                firstchunk = next(iterator)\n            except StopIteration:\n                firstchunk = ''\n\n            return itertools.chain([firstchunk], iterator)\n\n        def wsgi(env, start_resp):\n            # clear threadlocal to avoid inteference of previous requests\n            self._cleanup()\n\n            self.load(env)\n            try:\n                # allow uppercase methods only\n                if web.ctx.method.upper() != web.ctx.method:\n                    raise web.nomethod()\n\n                result = self.handle_with_processors()\n                if is_iter(result):\n                    result = peep(result)\n                else:\n                    result = [result]\n            except web.HTTPError as e:\n                result = [e.data]\n\n            def build_result(result):\n                for r in result:\n                    if PY2:\n                        yield utils.safestr(r)\n                    else:\n                        if isinstance(r, bytes):\n                            yield r\n                        elif isinstance(r, string_types):\n                            yield r.encode('utf-8')\n                        else:\n                            yield str(r).encode('utf-8')\n\n            result = build_result(result)\n\n            status, headers = web.ctx.status, web.ctx.headers\n            start_resp(status, headers)\n\n            def cleanup():\n                self._cleanup()\n                yield b'' # force this function to be a generator\n\n            return itertools.chain(result, cleanup())\n\n        for m in middleware:\n            wsgi = m(wsgi)\n\n        return wsgi\n\n    def run(self, *middleware):\n        \"\"\"\n        Starts handling requests. If called in a CGI or FastCGI context, it will follow\n        that protocol. If called from the command line, it will start an HTTP\n        server on the port named in the first command line argument, or, if there\n        is no argument, on port 8080.\n\n        `middleware` is a list of WSGI middleware which is applied to the resulting WSGI\n        function.\n        \"\"\"\n        return wsgi.runwsgi(self.wsgifunc(*middleware))\n\n    def stop(self):\n        \"\"\"Stops the http server started by run.\n        \"\"\"\n        if httpserver.server:\n            httpserver.server.stop()\n            httpserver.server = None\n\n    def cgirun(self, *middleware):\n        \"\"\"\n        Return a CGI handler. This is mostly useful with Google App Engine.\n        There you can just do:\n\n            main = app.cgirun()\n        \"\"\"\n        wsgiapp = self.wsgifunc(*middleware)\n\n        try:\n            from google.appengine.ext.webapp.util import run_wsgi_app\n            return run_wsgi_app(wsgiapp)\n        except ImportError:\n            # we're not running from within Google App Engine\n            return wsgiref.handlers.CGIHandler().run(wsgiapp)\n\n    def gaerun(self, *middleware):\n        \"\"\"\n        Starts the program in a way that will work with Google app engine,\n        no matter which version you are using (2.5 / 2.7)\n\n        If it is 2.5, just normally start it with app.gaerun()\n\n        If it is 2.7, make sure to change the app.yaml handler to point to the\n        global variable that contains the result of app.gaerun()\n\n        For example:\n\n        in app.yaml (where code.py is where the main code is located)\n\n            handlers:\n            - url: /.*\n              script: code.app\n\n        Make sure that the app variable is globally accessible\n        \"\"\"\n        wsgiapp = self.wsgifunc(*middleware)\n        try:\n            # check what version of python is running\n            version = sys.version_info[:2]\n            major   = version[0]\n            minor   = version[1]\n\n            if major != 2:\n                raise EnvironmentError(\"Google App Engine only supports python 2.5 and 2.7\")\n\n            # if 2.7, return a function that can be run by gae\n            if minor == 7:\n                return wsgiapp\n            # if 2.5, use run_wsgi_app\n            elif minor == 5:\n                from google.appengine.ext.webapp.util import run_wsgi_app\n                return run_wsgi_app(wsgiapp)\n            else:\n                raise EnvironmentError(\"Not a supported platform, use python 2.5 or 2.7\")\n        except ImportError:\n            return wsgiref.handlers.CGIHandler().run(wsgiapp)\n\n    def load(self, env):\n        \"\"\"Initializes ctx using env.\"\"\"\n        ctx = web.ctx\n        ctx.clear()\n        ctx.status = '200 OK'\n        ctx.headers = []\n        ctx.output = ''\n        ctx.environ = ctx.env = env\n        ctx.host = env.get('HTTP_HOST')\n\n        if env.get('wsgi.url_scheme') in ['http', 'https']:\n            ctx.protocol = env['wsgi.url_scheme']\n        elif env.get('HTTPS', '').lower() in ['on', 'true', '1']:\n            ctx.protocol = 'https'\n        else:\n            ctx.protocol = 'http'\n        ctx.homedomain = ctx.protocol + '://' + env.get('HTTP_HOST', '[unknown]')\n        ctx.homepath = os.environ.get('REAL_SCRIPT_NAME', env.get('SCRIPT_NAME', ''))\n        ctx.home = ctx.homedomain + ctx.homepath\n        #@@ home is changed when the request is handled to a sub-application.\n        #@@ but the real home is required for doing absolute redirects.\n        ctx.realhome = ctx.home\n        ctx.ip = env.get('REMOTE_ADDR')\n        ctx.method = env.get('REQUEST_METHOD')\n        ctx.path = env.get('PATH_INFO')\n        # http://trac.lighttpd.net/trac/ticket/406 requires:\n        if env.get('SERVER_SOFTWARE', '').startswith('lighttpd/'):\n            ctx.path = lstrips(env.get('REQUEST_URI').split('?')[0], ctx.homepath)\n            # Apache and CherryPy webservers unquote the url but lighttpd doesn't.\n            # unquote explicitly for lighttpd to make ctx.path uniform across all servers.\n            ctx.path = unquote(ctx.path)\n\n        if env.get('QUERY_STRING'):\n            ctx.query = '?' + env.get('QUERY_STRING', '')\n        else:\n            ctx.query = ''\n\n        ctx.fullpath = ctx.path + ctx.query\n\n        for k, v in iteritems(ctx):\n            # convert all string values to unicode values and replace\n            # malformed data with a suitable replacement marker.\n            if isinstance(v, bytes):\n                ctx[k] = v.decode('utf-8', 'replace')\n\n        # status must always be str\n        ctx.status = '200 OK'\n\n        ctx.app_stack = []\n\n    def _delegate(self, f, fvars, args=[]):\n        def handle_class(cls):\n            meth = web.ctx.method\n            if meth == 'HEAD' and not hasattr(cls, meth):\n                meth = 'GET'\n            if not hasattr(cls, meth):\n                raise web.nomethod(cls)\n            tocall = getattr(cls(), meth)\n            return tocall(*args)\n\n        if f is None:\n            raise web.notfound()\n        elif isinstance(f, application):\n            return f.handle_with_processors()\n        elif isclass(f):\n            return handle_class(f)\n        elif isinstance(f, string_types):\n            if f.startswith('redirect '):\n                url = f.split(' ', 1)[1]\n                if web.ctx.method == \"GET\":\n                    x = web.ctx.env.get('QUERY_STRING', '')\n                    if x:\n                        url += '?' + x\n                raise web.redirect(url)\n            elif '.' in f:\n                mod, cls = f.rsplit('.', 1)\n                mod = __import__(mod, None, None, [''])\n                cls = getattr(mod, cls)\n            else:\n                cls = fvars[f]\n            return handle_class(cls)\n        elif hasattr(f, '__call__'):\n            return f()\n        else:\n            return web.notfound()\n\n    def _match(self, mapping, value):\n        for pat, what in mapping:\n            if isinstance(what, application):\n                if value.startswith(pat):\n                    f = lambda: self._delegate_sub_application(pat, what)\n                    return f, None\n                else:\n                    continue\n            elif isinstance(what, string_types):\n                what, result = utils.re_subm(r'^%s\\Z' % (pat,), what, value)\n            else:\n                result = utils.re_compile(r'^%s\\Z' % (pat,)).match(value)\n\n            if result: # it's a match\n                return what, [x for x in result.groups()]\n        return None, None\n\n    def _delegate_sub_application(self, dir, app):\n        \"\"\"Deletes request to sub application `app` rooted at the directory `dir`.\n        The home, homepath, path and fullpath values in web.ctx are updated to mimic request\n        to the subapp and are restored after it is handled.\n\n        @@Any issues with when used with yield?\n        \"\"\"\n        web.ctx._oldctx = web.storage(web.ctx)\n        web.ctx.home += dir\n        web.ctx.homepath += dir\n        web.ctx.path = web.ctx.path[len(dir):]\n        web.ctx.fullpath = web.ctx.fullpath[len(dir):]\n        return app.handle_with_processors()\n\n    def get_parent_app(self):\n        if self in web.ctx.app_stack:\n            index = web.ctx.app_stack.index(self)\n            if index > 0:\n                return web.ctx.app_stack[index-1]\n\n    def notfound(self):\n        \"\"\"Returns HTTPError with '404 not found' message\"\"\"\n        parent = self.get_parent_app()\n        if parent:\n            return parent.notfound()\n        else:\n            return web._NotFound()\n\n    def internalerror(self):\n        \"\"\"Returns HTTPError with '500 internal error' message\"\"\"\n        parent = self.get_parent_app()\n        if parent:\n            return parent.internalerror()\n        elif web.config.get('debug'):\n            return debugerror()\n        else:\n            return web._InternalError()\n\ndef with_metaclass(mcls):\n    def decorator(cls):\n        body = vars(cls).copy()\n        # clean out class body\n        body.pop('__dict__', None)\n        body.pop('__weakref__', None)\n        return mcls(cls.__name__, cls.__bases__, body)\n    return decorator\n\nclass auto_application(application):\n    \"\"\"Application similar to `application` but urls are constructed\n    automatically using metaclass.\n\n        >>> app = auto_application()\n        >>> class hello(app.page):\n        ...     def GET(self): return \"hello, world\"\n        ...\n        >>> class foo(app.page):\n        ...     path = '/foo/.*'\n        ...     def GET(self): return \"foo\"\n        >>> app.request(\"/hello\").data\n        b'hello, world'\n        >>> app.request('/foo/bar').data\n        b'foo'\n    \"\"\"\n    def __init__(self):\n        application.__init__(self)\n\n        class metapage(type):\n            def __init__(klass, name, bases, attrs):\n                type.__init__(klass, name, bases, attrs)\n                path = attrs.get('path', '/' + name)\n\n                # path can be specified as None to ignore that class\n                # typically required to create a abstract base class.\n                if path is not None:\n                    self.add_mapping(path, klass)\n\n\n        @with_metaclass(metapage) #little hack needed or Py2 and Py3 compatibility\n        class page():\n            path = None\n\n        self.page = page\n\n# The application class already has the required functionality of subdir_application\nsubdir_application = application\n\nclass subdomain_application(application):\n    \"\"\"\n    Application to delegate requests based on the host.\n\n        >>> urls = (\"/hello\", \"hello\")\n        >>> app = application(urls, globals())\n        >>> class hello:\n        ...     def GET(self): return \"hello\"\n        >>>\n        >>> mapping = (r\"hello\\.example\\.com\", app)\n        >>> app2 = subdomain_application(mapping)\n        >>> app2.request(\"/hello\", host=\"hello.example.com\").data\n        b'hello'\n        >>> response = app2.request(\"/hello\", host=\"something.example.com\")\n        >>> response.status\n        '404 Not Found'\n        >>> response.data\n        b'not found'\n    \"\"\"\n    def handle(self):\n        host = web.ctx.host.split(':')[0] #strip port\n        fn, args = self._match(self.mapping, host)\n        return self._delegate(fn, self.fvars, args)\n\n    def _match(self, mapping, value):\n        for pat, what in mapping:\n            if isinstance(what, string_types):\n                what, result = utils.re_subm('^' + pat + '$', what, value)\n            else:\n                result = utils.re_compile('^' + pat + '$').match(value)\n\n            if result: # it's a match\n                return what, [x for x in result.groups()]\n        return None, None\n\ndef loadhook(h):\n    \"\"\"\n    Converts a load hook into an application processor.\n\n        >>> app = auto_application()\n        >>> def f(): \"something done before handling request\"\n        ...\n        >>> app.add_processor(loadhook(f))\n    \"\"\"\n    def processor(handler):\n        h()\n        return handler()\n\n    return processor\n\ndef unloadhook(h):\n    \"\"\"\n    Converts an unload hook into an application processor.\n\n        >>> app = auto_application()\n        >>> def f(): \"something done after handling request\"\n        ...\n        >>> app.add_processor(unloadhook(f))\n    \"\"\"\n    def processor(handler):\n        try:\n            result = handler()\n            is_gen = is_iter(result)\n        except:\n            # run the hook even when handler raises some exception\n            h()\n            raise\n\n        if is_gen:\n            return wrap(result)\n        else:\n            h()\n            return result\n\n    def wrap(result):\n        def next_hook():\n            try:\n                return next(result)\n            except:\n                # call the hook at the and of iterator\n                h()\n                raise\n\n        result = iter(result)\n        while True:\n            try:\n                yield next_hook()\n            except StopIteration:\n                return\n\n    return processor\n\ndef autodelegate(prefix=''):\n    \"\"\"\n    Returns a method that takes one argument and calls the method named prefix+arg,\n    calling `notfound()` if there isn't one. Example:\n\n        urls = ('/prefs/(.*)', 'prefs')\n\n        class prefs:\n            GET = autodelegate('GET_')\n            def GET_password(self): pass\n            def GET_privacy(self): pass\n\n    `GET_password` would get called for `/prefs/password` while `GET_privacy` for\n    `GET_privacy` gets called for `/prefs/privacy`.\n\n    If a user visits `/prefs/password/change` then `GET_password(self, '/change')`\n    is called.\n    \"\"\"\n    def internal(self, arg):\n        if '/' in arg:\n            first, rest = arg.split('/', 1)\n            func = prefix + first\n            args = ['/' + rest]\n        else:\n            func = prefix + arg\n            args = []\n\n        if hasattr(self, func):\n            try:\n                return getattr(self, func)(*args)\n            except TypeError:\n                raise web.notfound()\n        else:\n            raise web.notfound()\n    return internal\n\nclass Reloader:\n    \"\"\"Checks to see if any loaded modules have changed on disk and,\n    if so, reloads them.\n    \"\"\"\n\n    \"\"\"File suffix of compiled modules.\"\"\"\n    if sys.platform.startswith('java'):\n        SUFFIX = '$py.class'\n    else:\n        SUFFIX = '.pyc'\n\n    def __init__(self):\n        self.mtimes = {}\n\n    def __call__(self):\n        for mod in sys.modules.values():\n            self.check(mod)\n\n    def check(self, mod):\n        # jython registers java packages as modules but they either\n        # don't have a __file__ attribute or its value is None\n        if not (mod and hasattr(mod, '__file__') and mod.__file__):\n            return\n\n        try:\n            mtime = os.stat(mod.__file__).st_mtime\n        except (OSError, IOError):\n            return\n        if mod.__file__.endswith(self.__class__.SUFFIX) and os.path.exists(mod.__file__[:-1]):\n            mtime = max(os.stat(mod.__file__[:-1]).st_mtime, mtime)\n\n        if mod not in self.mtimes:\n            self.mtimes[mod] = mtime\n        elif self.mtimes[mod] < mtime:\n            try:\n                reload(mod)\n                self.mtimes[mod] = mtime\n            except ImportError:\n                pass\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n
===================================================================
diff --git a/src/web039/application.py b/src/web039/application.py
--- a/src/web039/application.py	
+++ b/src/web039/application.py	
@@ -375,7 +375,7 @@
 
         For example:
 
-        in app.yaml (where code.py is where the main code is located)
+        in app.yaml (where code_test.py is where the main code is located)
 
             handlers:
             - url: /.*
